{"meta":{"title":"编程分享网站","subtitle":null,"description":"Spring Cloud、Docker、毕业设计、毕业设计,毕业设计代做","author":"zhaokejin","url":"https://www.cicoding.com"},"pages":[{"title":"about","date":"2019-09-24T01:45:07.000Z","updated":"2022-09-21T11:31:12.000Z","comments":true,"path":"about/index.html","permalink":"https://www.cicoding.com/about/index.html","excerpt":"","text":"筱进GG7年+软件开发架构及管理经验，历任Java高级开发，目前从事架构相关工作。 目前的研究重心：Spring Cloud、Docker、Kubernetes，及其相关生态的技术，并总结项目落地过程中遇到的坑。 拥抱开源，多个项目开源在Github与Git@OSC上，欢迎Star、Follow。 GitHub：http://github.com/zhaokejin Gitee：http://gitee.com/zhaokejin 时光…2014年开始了代码的生涯！一去不回头。。。。 联系方式 QQ：210006540 邮箱：&#x32;&#x31;&#x30;&#x30;&#48;&#54;&#x35;&#52;&#48;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;"},{"title":"文章分类","date":"2024-02-01T13:53:17.131Z","updated":"2023-06-19T07:14:50.277Z","comments":false,"path":"categories/index.html","permalink":"https://www.cicoding.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-24T01:42:26.000Z","updated":"2022-09-21T11:31:12.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.cicoding.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring面试题总结(二)","slug":"spring2","date":"2024-02-25T09:12:38.000Z","updated":"2024-02-24T15:15:21.837Z","comments":false,"path":"spring/spring2/","link":"","permalink":"https://www.cicoding.com/spring/spring2/","excerpt":"","text":"Spring作为现代开发中最流行的框架之一，让开发者可以更加方便高效地构建应用系统。但是对于初学者而言，常常会遇到很多困惑。本篇文章收集了50道常见的Spring面试题，并对每道题进行了详细的解释，希望能够对读者有所帮助。 1.Spring是什么？作用是什么？Spring是一个轻量级的JavaEE框架，它主要解决企业应用中的复杂性问题。Spring框架有三个核心部分：IoC容器、AOP和数据访问&#x2F;集成层。Spring中的IoC容器提供了一种对象创建和对象之间关系管理的机制，以实现松散耦合和可扩展性。AOP提供了一种很好的方式来实现横向关注点的处理，如事务管理，安全检查，缓存等。数据访问&#x2F;集成层则提供了许多针对不同数据持久化技术的实现，比如JDBC，ORM和NoSQL。 2.你对IoC（控制反转 Inversion of Control）是怎么理解的？IoC是一种设计思想，通过将对象之间的依赖关系交给容器来管理，从而实现松散耦合。在Spring中，IoC容器扮演了一个中心角色，负责创建对象，装配对象之间的依赖关系，并管理它们的整个生命周期。IoC还提供了一些高级功能，如AOP和事件驱动等，可以进一步增强应用程序的可维护性和可扩展性。 3.什么是AOP（面向切面编程 Aspect Oriented Programming）？AOP是一种编程范式，它能够在程序运行期间动态地将代码切入到原有代码的流程中，从而实现横向关注点的处理，如日志记录、事务管理和安全检查等。在Spring中，AOP是通过代理模式来实现的，在创建Bean时为Bean生成一个代理对象，代理对象能够拦截指定方法的调用，并在执行前或执行后执行特定操作。 4.Spring中Bean之间的依赖关系是怎样的？在Spring中，Bean之间的依赖关系主要通过构造函数注入、Setter方法注入和自动注入来实现。构造函数注入是通过Bean的构造方法注入其他Bean作为参数来实现；Setter方法注入是通过Bean的Setter方法来注入其他Bean；自动注入则是通过IoC容器在Bean创建时自动发现并注入其他Bean，可以通过设置@Autowired或@Resource注解来完成。 5.Spring框架中的单例模式是怎样实现的？在Spring中，默认情况下，所有的Bean都是单例的。当IoC容器创建一个Bean时，它会缓存该Bean的实例，并在后续请求中返回相同的实例。这种机制可以提高应用程序的性能并减少内存消耗，但也需要注意线程安全和状态管理等问题。 6.Spring中的事务管理是如何实现的？Spring通过AOP在运行时动态地将事务相关的逻辑切入到指定的方法中，从而实现事务管理。通常情况下，Spring使用声明式事务管理来管理事务。开发者可以通过@Transactional注解或XML配置文件来定义事务范围、传播属性以及回滚规则等。 7.Spring的优势是什么？Spring的主要优势有： 1）提高了应用程序的可扩展性和可维护性。 2）提供了一种松散耦合的方式来管理对象之间的依赖关系。 3）提供了完整的数据访问&#x2F;集成层，支持多种持久化技术。 4）提供了AOP支持，可以很方便地实现横向关注点的处理。 5）提供了很好的集成支持，可以与其他框架无缝协作。 8.解释一下Spring中的BeanFactory和ApplicationContext有什么区别。BeanFactory是Spring IoC容器的最基本形式，提供了基本的IoC功能。它是延迟初始化的，即当一个Bean被实际使用时才被创建。ApplicationContext是BeanFactory的子接口，提供了更多的企业级功能，如AOP，事件驱动，国际化等。ApplicationContext也是预初始化的，即在容器启动时就已经创建了所有的Bean。 9.Spring中的注解有哪些？Spring中的常用注解有： 1）@Component、@Service、@Repository、@Controller：用于标识Bean的角色。 2）@Autowired、@Resource：用于自动装配Bean。 3）@PostConstruct、@PreDestroy：用于指定初始化和销毁方法。 4）@Transactional：用于声明式事务管理。 5）@Scope：用于指定Bean作用域。 10.Spring MVC框架的流程是怎样的？Spring MVC的处理流程如下： 1）客户端向服务器发起请求。 2）DispatcherServlet接收到请求并将请求发送给处理器映射器进行处理器的映射查找。 3）处理器映射器将请求的URL映射到相应的控制器(Controller)上，并返回处理器及其拦截器(如果有)。 4）DispatcherServlet调用处理器适配器(Adapter)执行映射的处理器(Controller)。 5）处理器(Controller)执行后返回ModelAndView对象。 6）DispatcherServlet将ModelAndView对象交给视图解析器(ViewResolver)进行解析。 7）视图解析器(ViewResolver)解析出对应的视图(View)。 8）DispatcherServlet将Model数据和View视图进行渲染后返回给客户端。 11.Spring Boot是什么？与传统的Spring框架有什么区别？Spring Boot是一种基于Spring的快速应用开发框架，它能够让开发者更加快速地搭建基于Spring的应用程序，并提供了自动化配置、快速启动等便利功能。相比传统的Spring框架，Spring Boot具有更简洁的配置方式和更快的启动速度，同时还提供了更多的功能和特性支持。 12.解释一下Spring的生命周期。在Spring中，Bean的生命周期包括以下几个阶段： 1）实例化：当IoC容器读取到Bean的定义后，创建一个新的Bean实例。 2）属性注入：IoC容器将Bean中声明的依赖关系和配置信息注入到Bean中。 3）BeanPostProcessor前置处理：如果Bean中定义了BeanPostProcessor接口的实现类，它们将在Bean初始化之前被调用。 4）初始化：如果Bean实现了InitializingBean接口，则在所有属性都被设置完毕后调用afterPropertiesSet()方法。同时，也可以通过@Bean(initMethod &#x3D; “init”)来指定Bean的初始化方法。 5）BeanPostProcessor后置处理：如果Bean中定义了BeanPostProcessor接口的实现类，它们将在Bean初始化之后被调用。 6）销毁：如果Bean实现了DisposableBean接口，则在容器关闭或者该Bean被从容器中移除时调用destroy()方法。同时，也可以通过@Bean(destroyMethod &#x3D; “destroy”)来指定Bean的销毁方法。 13.Spring中的IOC如何管理对象？在Spring中，IOC通过Bean工厂来管理对象，Bean工厂是提供了一种对象创建和对象之间关系管理的机制。它在读取配置文件时会自动创建和装配对象，并缓存这些对象以便后续使用。开发者可以通过构造器注入、Setter方法注入和自动注入等方式来管理对象之间的依赖关系。 14.Spring中的AOP的具体实现方式有哪些？Spring中实现AOP的主要方式有两种：JDK动态代理和CGLIB代理。JDK动态代理又叫接口代理，它是基于Java反射机制实现的，要求目标对象必须实现至少一个接口；CGLIB代理则是基于字节码操作实现的，当目标对象没有实现接口时，它就会使用CGLIB代理。通常情况下，Spring默认使用JDK动态代理来实现AOP，但如果目标对象没有实现任何接口，则会自动切换到使用CGLIB代理。 15.Spring中的JdbcTemplate是什么？使用JdbcTemplate需要做哪些配置？JdbcTemplate是Spring提供的一个对JDBC访问的封装，它简化了JDBC操作的繁琐和冗长，能够提高开发效率。使用JdbcTemplate需要在Spring的配置文件中配置基本数据源信息、配置JdbcTemplate Bean以及为JdbcTemplate Bean配置数据源。 16.解释一下Spring中的循环依赖问题。循环依赖指两个或多个Bean之间相互引用，形成了一个无限循环调用的情况。在Spring容器中，如果存在循环依赖，但是都是单例模式的Bean，则可以通过Spring容器提前暴露正在创建的Bean，从而避免循环依赖问题。如果存在循环依赖且其中一方是原型模式的Bean，则Spring无法处理这种情况。 17.Spring中的事件驱动机制是怎样的？有哪些默认事件？Spring中的事件驱动机制基于观察者模式实现。当一个Bean发生事件时，它会创建一个事件对象并将其发布到Spring容器上。容器中所有对该事件对象感兴趣的Bean都会收到事件通知并进行相应的处理。Spring中默认的事件有：ContextRefreshedEvent、ContextStartedEvent、ContextStoppedEvent和ContextClosedEvent。 18.Spring的MVC框架中，HandlerAdapter的作用是什么？HandlerAdapter是Spring MVC框架中的一个重要组件，它的作用是将请求交给相应的处理器(Controller)进行处理，并负责调用处理器的方法来生成ModelAndView对象。 19.@Autowired和@Resource注解用来干嘛的？@Autowired和@Resource注解是用于自动装配Bean的。@Autowired是Spring提供的注解，可以在Setter方法上、构造函数上、类属性上进行标注，用于自动注入匹配类型的Bean。@Resource是JavaEE提供的注解，可以在Setter方法上或类属性上进行标注，用于自动注入指定名称和类型匹配的Bean。 20.Spring中的事务传播属性有哪些？Spring中的事务传播属性主要有以下几种： 1）PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果不存在事务，则创建一个新的事务。 2）PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果不存在事务，则不开启事务。 3）PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果不存在事务，则抛出异常。 4）PROPAGATION_REQUIRES_NEW：无论是否存在事务，都创建一个新的事务并进行执行。","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.cicoding.com/tags/Spring/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"Spring面试题总结（一）","slug":"spring","date":"2024-02-24T09:12:38.000Z","updated":"2024-07-08T14:44:40.484Z","comments":false,"path":"spring/spring/","link":"","permalink":"https://www.cicoding.com/spring/spring/","excerpt":"","text":"1、谈谈你对Spring的理解？一个轻量级的IOC和AOP容器框架，是为Java应用程序提供基础性服务的一套框架。 目的是用于简化企业级应用程序的开发，使开发者只需要关心业务需求。 常见的三种配置方式： 基于XML的配置； 基于注解的配置； 基于Java的配置。 1.1 发展历程 1.2 Spirng的组成Spring Core：核心类库，提供IOC服务； Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDL、定时任务等）； Spring AOP：AOP服务； Spring DAO：对JDBC的抽象，简化了数据访问异常的处理； Sping ORM：对现有的ORM框架的支持； Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传； Spring MVC：提供面向Web应用的Model-View-Controller实现。 1.3 Spring的好处","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.cicoding.com/tags/Spring/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"Java 并发编程（二）","slug":"java-concurrent-programming2","date":"2024-02-24T09:12:38.000Z","updated":"2024-03-01T14:37:05.136Z","comments":false,"path":"java/java-concurrent-programming2/","link":"","permalink":"https://www.cicoding.com/java/java-concurrent-programming2/","excerpt":"","text":"1、并发编程三要素？1、原子性原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要么就全部都不执行。2、可见性可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。3、有序性有序性，即程序的执行顺序按照代码的先后顺序来执行。 2、实现可见性的方法有哪些？synchronized 或者 Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。 3、多线程的价值？1、发挥多核 CPU 的优势 多线程，可以真正发挥出多核 CPU 的优势来，达到充分利用 CPU 的目的，采用多线程的方式去同时完成几件事情而不互相干扰。2、防止阻塞从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因为在单核 CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。 多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。3、便于建模这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成几个小任务，任务 B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 4、创建线程的有哪些方式？1、继承 Thread 类创建线程类2、通过 Runnable 接口创建线程类3、通过 Callable 和 Future 创建线程4、通过线程池创建 5、创建线程的三种方式的对比？1、采用实现 Runnable、Callable 接口的方式创建多线程。优势是：线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。劣势是：编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread()方法。2、使用继承 Thread 类的方式创建多线程优势是：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread()方法，直接使用 this 即可获得当前线程。劣势是：线程类已经继承了 Thread 类，所以不能再继承其他父类。3、Runnable 和 Callable 的区别1、Callable 规定（重写）的方法是 call()，Runnable 规定（重写）的方法是 run()。2、Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的。3、Call 方法可以抛出异常，run 方法不可以。4、运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 6、线程的状态流转图线程的生命周期及五种基本状态： 初始状态 实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。 就绪状态 就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。 调用线程的start()方法，此线程进入就绪状态。 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。 当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。 锁池里的线程拿到对象锁后，进入就绪状态。 运行中状态 线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。 阻塞状态 阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。 等待 处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。 超时等待 处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。 终止状态 当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。 在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 等待队列 调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。 当调用Object.wait()进入等待队列 状态流转 7、Java 线程具有五中基本状态1、新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t &#x3D; new MyThread()；2、就绪状态（Runnable）：当调用线程对象的 start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待 CPU 调度执行，并不是说执行了 t.start()此线程立即就会执行；3、运行状态（Running）：当 CPU 开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；4、阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：1、等待阻塞：运行状态中的线程执行 wait()方法，使本线程进入到等待阻塞状态；2、同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；3、其他阻塞：通过调用线程的 sleep()或 join()或发出了 I&#x2F;O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。5、死亡状态（Dead）：线程执行完了或者因异常退出了 run()方法，该线程结束生命周期。 8、什么是线程池？有哪几种创建方式？线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。java 提供了一个 java.util.concurrent.Executor 接口的实现用于创建线程池。 9、四种线程池的创建：1、newCachedThreadPool 创建一个可缓存线程池2、newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数。3、newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。4、newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务。 10、线程池的优点？1、重用存在的线程，减少对象创建销毁的开销。2、可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。3、提供定时执行、定期执行、单线程、并发数控制等功能。 11、常用的并发工具类有哪些？1、CountDownLatch2、CyclicBarrier3、Semaphore4、Exchanger 12、CyclicBarrier 和 CountDownLatch 的区别1、CountDownLatch 简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用 countDown()方法发出通知后，当前线程才可以继续执行。2、cyclicBarrier 是所有线程都进行等待，直到所有线程都准备好进入 await()方法之后，所有线程同时开始执行！3、CountDownLatch 的计数器只能使用一次。而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。4、CyclicBarrier 还提供其他有用的方法，比如 getNumberWaiting 方法可以获得 CyclicBarrier 阻塞的线程数量。isBroken 方法用来知道阻塞的线程是否被中断。如果被中断返回 true，否则返回 false。 13、synchronized 的作用？在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 既可以加在一段代码上，也可以加在方法上。 14、volatile 关键字的作用对于可见性，Java 提供了 volatile 关键字来保证可见性。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。 15、什么是 CASCAS 是 compare and swap 的缩写，即我们所说的比较交换。cas 是一种基于锁的操作，而且是乐观锁。在 java 中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的( AtomicInteger,AtomicBoolean,AtomicLong)。 16、CAS 的问题1、CAS 容易造成 ABA 问题一个线程 a 将数值改成了 b，接着又改成了 a，此时 CAS 认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次version 加 1。在 java5 中，已经提供了 AtomicStampedReference 来解决问题。2、不能保证代码块的原子性CAS 机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证 3 个变量共同进行原子性的更新，就不得不使用 synchronized 了。3、CAS 造成 CPU 利用率增加之前说过了 CAS 里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用。 17、什么是 Future？在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不管是继承 thread 类还是实现 runnable 接口，都无法保证获取到之前的执行结果。通过实现 Callback 接口，并用 Future 可以来接收多线程的执行结果。Future 表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加Callback 以便在任务执行成功或失败后作出相应的操作。 18、什么是 AQSAQS 是 AbustactQueuedSynchronizer 的简称，它是一个 Java 提高的底层同步工具类，用一个 int 类型的变量表示同步状态，并提供了一系列的 CAS 操作来管理这个同步状态。AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于AQS 的。 19、AQS 支持两种同步方式：1、独占式2、共享式这样方便使用者实现不同类型的同步组件，独占式如 ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如 ReentrantReadWriteLock。总之，AQS 为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。 20、ReadWriteLock 是什么首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 21、FutureTask 是什么这个其实前面有提到过，FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。 22、synchronized 和 ReentrantLock 的区别synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock 比 synchronized 的扩展性体现在几点上：1、ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁2、ReentrantLock 可以获取各种锁的信息3、ReentrantLock 可以灵活地实现多路通知另外，二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word，这点我不能确定。 23、什么是乐观锁和悲观锁1、乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。2、悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。 24、线程 B 怎么知道线程 A 修改了变量1、volatile 修饰变量2、synchronized 修饰修改变量的方法3、wait&#x2F;notify4、while 轮询 25、synchronized、volatile、CAS 比较1、synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。2、volatile 提供多线程共享变量可见性和禁止指令重排序优化。3、CAS 是基于冲突检测的乐观锁（非阻塞） 26、sleep 方法和 wait 方法有什么区别?这个问题常问，sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器 27、ThreadLocal 是什么？有什么用？ThreadLocal 是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。简单说 ThreadLocal 就是一种以空间换时间的做法，在每个 Thread 里面维护了一个以开地址法实现的 ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。 28、为什么 wait()方法和 notify()&#x2F;notifyAll()方法要在同步块中被调用这是 JDK 强制的，wait()方法和 notify()&#x2F;notifyAll()方法在调用前都必须先获得对象的锁 29、多线程同步有哪几种方法？Synchronized 关键字，Lock 锁实现，分布式锁等。 30、线程的调度策略线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：1、线程体中调用了 yield 方法让出了对 cpu 的占用权利2、线程体中调用了 sleep 方法使线程进入睡眠状态3、线程由于 IO 操作受到阻塞4、另外一个更高优先级线程出现5、在支持时间片的系统中，该线程的时间片用完 31、ConcurrentHashMap 的并发度是什么ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着最多同时可以有 16 条线程操作 ConcurrentHashMap，这也是ConcurrentHashMap 对 Hashtable 的最大优势，任何情况下，Hashtable 能同时有两条线程获取 Hashtable 中的数据吗？ 32、Linux 环境下如何查找哪个线程使用 CPU 最长1、获取项目的 pid，jps 或者 ps -ef | grep java，这个前面有讲过2、top -H -p pid，顺序不能改变 33、Java 死锁以及如何避免？Java 中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java 死锁情况出现至少两个线程和两个或更多资源。Java 发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。 34、死锁的原因1、是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环。例如：线程在获得了锁 A 并且没有释放的情况下去申请锁 B，这时，另一个线程已经获得了锁 B，在释放锁 B 之前又要先获得锁 A，因此闭环发生，陷入死锁循。2、默认的锁申请操作是阻塞的。所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。总之是尽量避免在一个同步方法中调用其它对象的延时方法和同步方法。 35、怎么唤醒一个阻塞的线程如果线程是因为调用了 wait()、sleep()或者 join()方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它；如果线程遇到了 IO 阻塞，无能为力，因为 IO 是操作系统实现的，Java 代码并没有办法直接接触到操作系统。 36、不可变对象对多线程有什么帮助前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。 37、什么是多线程的上下文切换多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。 38、如果你提交任务时，线程池队列已满，这时会发生什么这里区分一下：1、如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务 2、如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略, RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy 39、Java 中用到的线程调度算法是什么抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 40、什么是线程调度器(Thread Scheduler)和时间分片(TimeSlicing)？线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。 41、什么是自旋很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 42、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：1、可以使锁更公平2、可以使线程在等待锁的时候响应中断3、可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间4、可以在不同的范围，以不同的顺序获取和释放锁 43、单例模式的线程安全性老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：1、饿汉式单例模式的写法：线程安全2、懒汉式单例模式的写法：非线程安全3、双检锁单例模式的写法：线程安全 44、Semaphore 有什么作用Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n&#x3D;1，相当于变成了一个 synchronized 了。 45、Executors 类是什么？Executors 为 Executor，ExecutorService，ScheduledExecutorService，ThreadFactory 和 Callable 类提供了一些工具方法。Executors 可以用于方便的创建线程池 46、线程类的构造方法、静态块是被哪个线程调用的这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了Thread1，main 函数中 new 了 Thread2，那么：1、Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是Thread2 自己调用的2、Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是Thread1 自己调用的 47、同步方法和同步块，哪个是更好的选择?同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。 48、Java 线程数过多会造成什么异常？1、线程的生命周期开销非常高2、消耗过多的 CPU 资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。3、降低稳定性JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.cicoding.com/tags/Java/"},{"name":"JUC","slug":"JUC","permalink":"https://www.cicoding.com/tags/JUC/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"MySQL面试题","slug":"mysql","date":"2024-02-24T09:12:38.000Z","updated":"2024-02-24T15:35:45.658Z","comments":false,"path":"mysql/mysql/","link":"","permalink":"https://www.cicoding.com/mysql/mysql/","excerpt":"","text":"1、MySQL 中有哪几种锁？ 共享锁（Shared Lock）：也称为读锁（Read Lock），允许多个事务同时持有共享锁，且不互斥。共享锁适用于读操作，不阻塞其他事务的读操作。 排他锁（Exclusive Lock）：也称为写锁（Write Lock），排他锁在事务对表进行更新、删除等写操作时使用。排他锁只允许一个事务持有，其他事务不能同时持有共享锁或排他锁。 表级锁（Table-level Lock）：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。表级锁是对整张表进行锁定，可以分为两种类型：共享锁和排他锁。 行级锁（Row-level Lock）：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 行级锁是针对数据表中的行进行锁定，锁定指定的行，其他事务对同一行的其他操作会被阻塞。 页级锁（Page-level Lock）：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 页级锁作用于表的页（通常是一组连续的数据行）。 间隙锁（Gap Lock）：间隙锁用于锁定某个范围内的数据，而不是具体的行，用于防止其他会话在某个范围内插入新数据，从而确保查询的一致性。 临键锁（Next-Key Lock）：临键锁是一种组合了行级锁和间隙锁的锁类型，用于防止幻读（Phantom Read）和确保范围查询的一致性。 意向锁：意向锁（IS、IX）是InnoDB引擎操作数据之前自动加的，不需要用户干预；意向共享锁表示事务准备给数据行加入共享锁，意向排它锁表示事务准备给数据行加入排他锁。 2、MySQL数据库中有哪些不同的表格？在 MySQL 中，数据表是一个或多个字段的集合（有组织排列），并且每个字段可以存储特定的类型数据。常见的 MySQL 表格有以下几种： 1、MyISAM：MyISAM 是最早出现的 MySQL 存储引擎之一，它默认不支持事务特性，但是表格可以被压缩成只读表格。MyISAM 适用于非事务型应用程序和具有高度静态的数据内容的应用程序。 2、InnoDB：InnoDB 是一种与 SQL 标准完全兼容的 MySQL 引擎。它提供了 ACID 支持，并支持通过事务来保证数据完整性和一致性。它还包括行级锁特性，这意味着同时发生的写操作不会相互影响。在 InnoDB 中，保存数据库的文件称为表空间（tablespace），InnoDb使用聚簇索引，数据的物理存储顺序就是索引的顺序。 3、MEMORY：Memory 引擎将数据存储在内存中，因此比较适合用于速度要求高、数据持久性要求少的应用。如果服务器重新启动，保存在 Memory 引擎表格中的数据将消失。由于其存储方式的局限性，它仅适用于比较小的数据库。 4、Heap：Heap 存储引擎是 MySQL 的一个轻量级存储引擎。它将数据保存在内存中，并允许高速访问，但如果服务器重新启动，则所有 Heap 表格中的数据都会消失。相比于其它表格类型，Heap 存储引擎非常限制筛选、统计和排序性能。 5、CSV：CSV 存储引擎可以使用类似电子表格的格式来读取、写入和操作 Comma-Separated Value （CSV）文件。CSV 格式是一种文本文件格式，其中不同字段之间用逗号分隔开，在需要进行大批量数据导入的场景下具有较高的优势。 6、Blackhole：Blackhole 存储引擎向接受但并不真正记录或保留任何数据。当使用该引擎的表接收数据写入时会直接被丢弃, 这个模式可能会对因为需要附加处理而被阻塞的精细生产环境有所帮助。 7、Merge: 基于联合多个 MyISAM 表派生出新表的技术，可实现多个表操作简便，但由于 MyISAM 的限制，这一功能缺乏完善性。 总之，MySQL 提供了多种机制，以让用户根据应用的特定要求选择不同的存储引擎类型，根据用户的应用特点以及性能需求作出选择。用户选择的引擎需要考虑到保证数据完整性、并发处理能力、查询效率等多个方面。 3、简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别MyISAM：不支持事务，但是每次查询都是原子的；支持表级锁，即每次操作是对整个表加锁；存储表的总行数；一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。InnoDb：支持 ACID 的事务，支持事务的四种隔离级别；支持行级锁及外键约束：因此可以支持写并发；不存储总行数：一个 InnoDb 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制；主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持 B+树结构，文件的大调整 。 4、MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？SQL 标准定义的四个隔离级别为：1、read uncommited ：读到未提交数据2、read committed：脏读，不可重复读3、repeatable read：可重读4、serializable ：串行事物 5、CHAR 和 VARCHAR 的区别？1、CHAR 和 VARCHAR 类型在存储和检索方面有所不同2、CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255 当 CHAR值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。 6、主键和候选键有什么区别？表格的每一行都由主键唯一标识,一个表只有一个主键。主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。 7、myisamchk 是用来做什么的？它用来压缩 MyISAM 表，这减少了磁盘或内存使用。MyISAM Static 和 MyISAM Dynamic 有什么区别？在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT，BLOB 等字段，以适应不同长度的数据类型。MyISAM Static 在受损情况下更容易恢复。 8、如果一个表有一列定义为 TIMESTAMP，将发生什么？每当行被更改时，时间戳字段将获取当前时间戳。列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。怎样才能找出最后一次插入时分配了哪个自动增量？LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需要指定表名称。 9、你怎么看到为表格定义的所有索引？索引是通过以下方式为表格定义的： 1SHOW INDEX FROM &lt;tablename&gt;; 10、LIKE 声明中的％和_是什么意思？％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。如何在 Unix 和 MySQL 时间戳之间进行转换？UNIX_TIMESTAMP 是从 MySQL 时间戳转换为 Unix 时间戳的命令FROM_UNIXTIME 是从 Unix 时间戳转换为 MySQL 时间戳的命令 11、列对比运算符是什么？在 SELECT 语句的列比较中使用&#x3D;，&lt;&gt;，&lt;&#x3D;，&lt;，&gt; &#x3D;，&gt;，&lt;&lt;，&gt;&gt;，&lt;&#x3D;&gt;，AND，OR 或 LIKE 运算符。 12、BLOB 和 TEXT 有什么区别？BLOB 是一个二进制对象，可以容纳可变数量的数据。TEXT 是一个不区分大小写的 BLOB。BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT 值不区分大小写。 13、MySQL_fetch_array 和 MySQL_fetch_object 的区别是什么？以下是 MySQL_fetch_array 和 MySQL_fetch_object 的区别：MySQL_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。MySQL_fetch_object – 从数据库返回结果行作为对象。 14、MyISAM 表格将在哪里存储，并且还提供其存储格式？每个 MyISAM 表格以三种格式存储在磁盘上：·“.frm”文件存储表定义·数据文件具有“.MYD”（MYData）扩展名索引文件具有“.MYI”（MYIndex）扩展名 15、MySQL 如何优化 DISTINCT？DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。SELECT DISTINCT t1.a FROM t1,t2 where t1.a&#x3D;t2.a; 16、如何显示前 50 行？在 MySQL 中，使用以下代码查询显示前 50 行：SELECT * FROM LIMIT 0,50; 17、可以使用多少列创建索引？任何标准表最多可以创建 16 个索引列。 18、NOW（）和 CURRENT_DATE（）有什么区别？NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。CURRENT_DATE（）仅显示当前年份，月份和日期。 19、什么是非标准字符串类型？1、TINYTEXT2、TEXT3、MEDIUMTEXT4、LONGTEXT 20、什么是通用 SQL 函数？1、CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。 2、FORMAT(X, D)- 格式化数字 X 到 D 有效数字。3、CURRDATE(), CURRTIME()- 返回当前日期或时间。4、NOW（） – 将当前日期和时间作为一个值返回。5、MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。6、HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。7、DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄8、SUBTIMES（A，B） – 确定两次之间的差异。9、FROMDAYS（INT） – 将整数天数转换为日期值。 21、MySQL 支持事务吗？在缺省模式下，MySQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，MySQL 是不支持事务的。但是如果你的 MySQL 表类型是使用 InnoDB Tables 或 BDB tables 的话，你的MySQL 就可以使用事务处理,使用 SETAUTOCOMMIT&#x3D;0 就可以使 MySQL 允许在非 autocommit 模式，在非autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK来回滚你的更改。 22、MySQL 里记录货币用什么字段类型好NUMERIC 和 DECIMAL 类型被 MySQL 实现为同样的类型，这在 SQL92 标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定。例如：salary DECIMAL(9,2)在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。因此，在这种情况下，能被存储在 salary 列中的值的范围是从-9999999.99 到9999999.99。 23、MySQL 有关权限的表都有哪几个？MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 MySQL 数据库里，由 MySQL_install_db 脚本初始化。这些权限表分别 user，db，table_priv，columns_priv 和 host。 24、列的字符串类型可以是什么？字符串类型是：1、SET2、BLOB3、ENUM4、CHAR5、TEXT 25、MySQL 数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？1、设计良好的数据库结构，允许部分数据冗余，尽量避免 join 查询，提高效率。2、选择合适的表字段数据类型和存储引擎，适当的添加索引。3、MySQL 库主从读写分离。4、找规律分表，减少单表中的数据量提高查询速度。5、添加缓存机制，比如 memcached，apc 等。6、不经常改动的页面，生成静态页面。7、书写高效率的 SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1,field_2, field_3 FROM TABLE. 26、锁的优化策略1、读写分离2、分段加锁3、减少锁持有的时间4.多个线程尽量以相同的顺序去获取资源不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。 27、索引的底层实现原理和优化B+树，经过优化的 B+树主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此 InnoDB 建议为大部分表使用默认自增的主键作为主索引。 28、什么情况下设置了索引但无法使用1、以“%”开头的 LIKE 语句，模糊匹配2、OR 语句前后没有同时使用索引3、数据类型出现隐式转化（如 varchar 不加单引号的话可能会自动转换为 int 型） 29、实践中如何优化 MySQL最好是按照以下顺序优化：1、SQL 语句及索引的优化2、数据库表结构的优化3、系统配置的优化4、硬件的优化详细可以查看 阿里 P8 架构师谈：MySQL 慢查询优化、索引优化、以及表等优化总结 30、优化数据库的方法1、选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL，例如’省份’、’性别’最好适用 ENUM2、使用连接(JOIN)来代替子查询3、适用联合(UNION)来代替手动创建的临时表4、事务处理5、锁定表、优化事务处理6、适用外键，优化锁定表7、建立索引8、优化查询语句 31、简单描述 MySQL 中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。普通索引(由关键字 KEY 或 INDEX 定义的索引)的唯一任务是加快对数据的访问速度。普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。索引可以覆盖多个数据列，如像 INDEX(columnA, columnB)索引，这就是联合索引。索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。 32、数据库中的事务是什么?事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。事务特性：1、原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。2、一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态 3、隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，4、持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。或者这样理解：事务就是被绑定在一起作为一个逻辑工作单元的 SQL 语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过 ACID 测试，即原子性，一致性，隔离性和持久性。 33、SQL 注入漏洞产生的原因？如何防止？SQL 注入产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。防止 SQL 注入的方式：开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置执行 sql 语句时使用 addslashes 进行 sql 语句转换Sql 语句书写尽量不要省略双引号和单引号。过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。 提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。 34、为表中得字段选择合适得数据类型字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,text优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型 35、存储时期Datatime:以 YYYY-MM-DD HH:MM:SS 格式存储时期时间，精确到秒，占用 8 个字节得存储空间，datatime 类型与时区无关Timestamp:以时间戳格式存储，占用 4 个字节，范围小 1970-1-1 到 2038-1-19，显示依赖于所指定得时区，默认在第一个列行的数据修改时可以自动得修改timestamp 列得值Date:（生日）占用得字节数比使用字符串.datatime.int 储存要少，使用 date 只需要 3 个字节，存储日期月份，还可以利用日期时间函数进行日期间得计算Time:存储时间部分得数据注意:不要使用字符串类型来存储日期时间数据（通常比字符串占用得储存空间小，在进行查找过滤可以利用日期得函数）使用 int 存储日期时间不如使用 timestamp 类型 36、对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：1、索引的目的是什么？快速访问数据表中的特定信息，提高检索速度创建唯一性索引，保证数据库表中每一行数据的唯一性。加速表和表之间的连接使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间2、索引对数据库系统的负面影响是什么？负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。3、为数据表建立索引的原则有哪些？在最频繁使用的、用以缩小查询范围的字段上建立索引。在频繁使用的、需要排序的字段上建立索引4、什么情况下不宜建立索引？ 对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等 37、解释 MySQL 外连接、内连接与自连接的区别先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL 来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL 目前还不支持全外连接。38、Myql 中的事务回滚机制概述事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚 39、SQL 语言包括哪几部分？每部分都有哪些操作关键字？SQL 语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（DQL）四个部分。数据定义：Create Table,Alter Table,Drop Table, Craete&#x2F;Drop Index 等数据操纵：Select ,insert,update,delete,数据控制：grant,revoke数据查询：select 40、完整性约束包括哪些？数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。分为以下四类：1、实体完整性：规定表的每一行在表中是惟一的实体。2、域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。3、参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。4、用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。 41、什么是锁？答： ​ 数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。​ 加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。​ 基本锁类型：锁包括行级锁和表级锁 42、什么叫视图？游标是什么？答：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 43、什么是存储过程？用什么来调用？答：存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。 44、如何通俗地理解三个范式？答： 第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解；第二范式：2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；第三范式：3NF 是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 范式化设计优缺点:优点: 可以尽量得减少数据冗余，使得更新快，体积小缺点: ​ 对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化反范式化:优点:可以减少表得关联，可以更好得进行索引优化缺点:数据冗余以及数据异常，数据得修改需要更多的成本 45、什么是基本表？什么是视图？答：基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表 46、试述视图的优点？答： 视图能够简化用户的操作 视图使用户能以多种角度看待同一数据； 视图为数据库提供了一定程度的逻辑独立性； 视图能够对机密数据提供安全保护。 47、 NULL 是什么意思答：NULL 这个值表示 UNKNOWN(未知):它不表示“”(空字符串)。对 NULL 这个值的任何比较都会生产一个 NULL 值。您不能把任何值与一个 NULL 值进行比较，并在逻辑上希望获得一个答案。使用 IS NULL 来进行 NULL 判断 48、主键、外键和索引的区别？主键、外键和索引的区别定义：主键–唯一标识一条记录，不能有重复的，不允许为空外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值索引–该字段没有重复值，但可以有一个空值作用：主键–用来保证数据完整性外键–用来和其他表建立联系用的索引–是提高查询排序的速度个数：主键–主键只能有一个外键–一个表可以有多个外键索引–一个表可以有多个唯一索引 49、你可以用什么来确保表格里的字段只接受特定范围里的值?答：Check 限制，它在数据库表格里被定义，用来限制输入该列的值。触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求触发器在表格里被定义，这可能会在某些情况下影响到性能 。 50、说说对 SQL 语句优化有哪些方法？（选择几条）1、Where 子句中：where 表之间的连接必须写在其他 Where 条件之前，那些可以过滤掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。2、用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。3、 避免在索引列上使用计算4、避免在索引列上使用 IS NULL 和 IS NOT NULL5、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描7、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.cicoding.com/tags/MySQL/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"Java 并发编程（一）","slug":"java-concurrent-programming1","date":"2024-02-24T09:12:29.000Z","updated":"2024-03-01T13:54:40.466Z","comments":false,"path":"java/java-concurrent-programming1/","link":"","permalink":"https://www.cicoding.com/java/java-concurrent-programming1/","excerpt":"","text":"1、在 java 中守护线程和本地线程区别？java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(boolon)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在 Thread.start()之前调用，否则运行时会抛出异常。两者的区别：唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。 2、线程与进程的区别？进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。一个程序至少有一个进程,一个进程至少有一个线程。 3、什么是多线程中的上下文切换？多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用CPU发生的切换数据等就是上下文切换。 4、死锁与活锁的区别，死锁与饥饿的区别？死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 产生死锁的必要条件： 1、互斥条件：所谓互斥就是进程在某一时间内独占资源。2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。3、不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。 Java 中导致饥饿的原因： 1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。 5、Java 中用到的线程调度算法是什么？采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。 6、什么是线程组，为什么在 Java 中不推荐使用？ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。 为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。 7、为什么使用 Executor 框架？每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。 8、在 Java 中 Executor 和 Executors 的区别？Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 Executor 接口对象能执行我们的线程任务。 ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 使用 ThreadPoolExecutor 可以创建自定义线程池。 Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 get()方法获取计算的结果。 9、什么是 Java Timer 类？如何创建一个有特定时间间隔的任务？java.util.Timer 是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer 类可以用安排一次性任务或者周期任务。java.util.TimerTask 是一个实现了 Runnable 接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用 Timer 去安排它的执行。 10、什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 CAS 操作——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的 CPU 指令都支持 CAS的原子操作。原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。 java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个 boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过） 11、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：可以使锁更公平可以使线程在等待锁的时候响应中断可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间可以在不同的范围，以不同的顺序获取和释放锁 12、什么是 Executors 框架？Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors 框架可以非常方便的创建一个线程池。 13、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。JDK7 提供了 7 个阻塞队列。分别是：ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。DelayQueue：一个使用优先级队列实现的无界阻塞队列。SynchronousQueue：一个不存储元素的阻塞队列。LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized 这些关键字。而在 java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。 14、什么是 Callable 和 Future?Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。可以认为是带有回调的 Runnable。Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable用于产生结果，Future 用于获取结果。 15、什么是 FutureTask?使用 ExecutorService 启动任务。在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable接口所以它可以提交给 Executor 来执行。 16、什么是并发容器的实现？何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如 Vector，Hashtable，以及 Collections.synchronizedSet，synchronizedList 等方法返回的容器。可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized。并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。 17、多线程同步和互斥有几种实现方法，都是什么？线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。 18、什么是竞争条件？你怎样发现和解决竞争？当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。 19、你将如何使用 thread dump？你将如何分析 Thread dump？新建状态（New）用 new 语句创建的线程处于新建状态，此时它和其他 Java 对象一样，仅仅在堆区中被分配了内存。就绪状态（Runnable） 当一个线程对象创建后，其他线程调用它的 start()方法，该线程就进入就绪状态，Java 虚拟机会为它创建方法调用栈和程序计数器。处于这个状态的线程位于可运行池中，等待获得 CPU 的使用权。 运行状态（Running） 处于这个状态的线程占用 CPU，执行程序代码。只有处于就绪状态的线程才有机会转到运行状态。 阻塞状态（Blocked） 阻塞状态是指线程因为某些原因放弃 CPU，暂时停止运行。当线程处于阻塞状态时，Java 虚拟机不会给线程分配 CPU。直到线程重新进入就绪状态，它才有机会转到运行状态。 阻塞状态可分为以下 3 种：位于对象等待池中的阻塞状态（Blocked in object’s wait pool）：当线程处于运行状态时，如果执行了某个对象的 wait()方法，Java 虚拟机就会把线程放到这个对象的等待池中，这涉及到“线程通信”的内容。位于对象锁池中的阻塞状态（Blocked in object’s lock pool）：当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java 虚拟机就会把这个线程放到这个对象的锁池中，这涉及到“线程同步”的内容。其他阻塞状态（Otherwise Blocked）：当前线程执行了 sleep()方法，或者调用了其他线程的 join()方法，或者发出了 I&#x2F;O请求时，就会进入这个状态。 20、为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代码。但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把 run 方法当作普通方法去执行。 21、Java 中你怎样唤醒一个阻塞的线程？在 Java 发展史上曾经使用 suspend()、resume()方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。解决方案可以使用以对象为目标的阻塞，即利用 Object 类的 wait()和 notify()方法实现线程阻塞。首先，wait、notify 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行；其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。 22、在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？CyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用。 Java 的 concurrent 包里面的 CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。你可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个对象上的 await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为 0 为止。所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。CountDownLatch 的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个 CountDownLatch 对象的 await()方法，其他的任务执行完自己的任务后调用同一个 CountDownLatch 对象上的 countDown()方法，这个调用 await()方法的任务将一直阻塞等待，直到这个 CountDownLatch 对象的计数值减到 0 为止。CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 23、什么是不可变对象，它对写并发应用有什么帮助？不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不可变类，如 String、基本类型的包装类、BigInteger 和 BigDecimal 等。不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。 不可变对象永远是线程安全的。只有满足如下状态，一个对象才是不可变的；它的状态不能在创建后再被修改；所有域都是 final 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出） 。 24、什么是多线程中的上下文切换？在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB 还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到 CPU 的内存中，直到他们被再次使用。上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征 。 25、Java 中用到的线程调度算法是什么？计算机通常只有一个 CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU 的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得 CPU 的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待 CPU,JAVA 虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配 CPU 的使用权. 有两种调度模型：分时调度模型和抢占式调度模型。分时调度模型是指让所有的线程轮流获得 cpu 的使用权,并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.cicoding.com/tags/Java/"},{"name":"JUC","slug":"JUC","permalink":"https://www.cicoding.com/tags/JUC/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"虚拟DOM","slug":"vue-virtual-dom","date":"2024-02-05T07:30:03.000Z","updated":"2024-02-03T02:44:04.281Z","comments":false,"path":"vue/vue-virtual-dom/","link":"","permalink":"https://www.cicoding.com/vue/vue-virtual-dom/","excerpt":"","text":"1. 对虚拟DOM的理解？从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能 虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。 另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。 2. 虚拟DOM的解析过程虚拟DOM的解析过程： 首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。 当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。 最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。 3. 为什么要用虚拟DOM（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能 看一下页面渲染的流程：解析HTML -&gt; 生成DOM -&gt; 生成 CSSOM -&gt; Layout -&gt; Paint -&gt; Compiler 下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶ 真实DOM∶ 生成HTML字符串＋重建所有的DOM元素 虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新 Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。 （2）跨平台 Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。 4. 虚拟DOM真的比真实DOM性能好吗 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。 正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。 5. DIFF算法的原理在新老虚拟DOM对比时： 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除) 比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。 匹配时，找到相同的子节点，递归比较子节点 在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。 6. Vue中key的作用vue 中 key 值的作用可以分为两种情况来考虑： 第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。 第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。 key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速 更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key &#x3D;&#x3D;&#x3D; b.key对比中可以避免就地复用的情况。所以会更加准确。 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快 7. 为什么不建议用index作为key?使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2…这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.cicoding.com/tags/VUE/"},{"name":"Vuex","slug":"Vuex","permalink":"https://www.cicoding.com/tags/Vuex/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"Vue 3.0","slug":"vue-3.0","date":"2024-02-05T01:30:03.000Z","updated":"2024-02-03T02:41:38.116Z","comments":false,"path":"vue/vue-3.0/","link":"","permalink":"https://www.cicoding.com/vue/vue-3.0/","excerpt":"","text":"1. Vue3.0有什么更新（1）监测机制的改变 3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。 消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制： （2）只能监测属性，不能监测对象 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 （3）模板 作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 （4）对象式的组件声明方式 vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。 3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易 （5）其它方面的更改 持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 tree shaking 优化，提供了更多的内置功能。 2. defineProperty和proxy的区别Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter。这样当追踪数据发生变化时，setter 会被自动调用。 Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。 但是这样做有以下问题： 添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过$set 来调用Object.defineProperty()处理。 无法监控到数组下标和长度的变化。 Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于Object.defineProperty()，其有以下特点： Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。 Proxy 可以监听数组的变化。 3. Vue3.0 为什么要用 proxy？在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶ 不需用使用 Vue.$set 或 Vue.$delete 触发响应式。 全方位的数组变化检测，消除了Vue2 无效的边界情况。 支持 Map，Set，WeakMap 和 WeakSet。 Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶ get 收集依赖 Set、delete 等触发依赖 对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。 4. Vue 3.0 中的 Vue Composition API？在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题： 由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。 Vue 组件过于依赖this上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在methods 中的this竟然指向组件实例来不指向methods所在的对象。这也使得 TypeScript 在Vue2 中很不好用。 于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。 如下，是一个使用了 Vue Composition API 的 Vue3 组件： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt; Count: &#123;&#123; count &#125;&#125; &lt;/button&gt;&lt;/template&gt; &lt;script&gt;// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数import &#123; ref, computed, onMounted &#125; from &#x27;vue&#x27; export default &#123; setup() &#123;// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数 const count = ref(0) // Vue2中需要在methods option中声明的函数，现在直接声明 function increment() &#123; count.value++ &#125; // 对应于Vue2中的mounted声明周期 onMounted(() =&gt; console.log(&#x27;component mounted!&#x27;)) return &#123; count, increment &#125; &#125;&#125;&lt;/script&gt; 显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性 5. Composition API与React Hook很像，区别是什么从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制 不能在循环、条件、嵌套函数中调用Hook 必须确保总是在你的React函数的顶层调用Hook useEffect、useMemo等函数必须手动确定依赖关系 而Composition API是基于Vue的响应式系统实现的，与React Hook的相比 声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢 Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用 响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。 虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.cicoding.com/tags/VUE/"},{"name":"Vuex","slug":"Vuex","permalink":"https://www.cicoding.com/tags/Vuex/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"Vuex","slug":"vuex","date":"2024-02-04T01:30:03.000Z","updated":"2024-02-03T02:39:45.165Z","comments":false,"path":"vue/vuex/","link":"","permalink":"https://www.cicoding.com/vue/vuex/","excerpt":"","text":"1. Vuex 的原理Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。 Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。 （1）核心流程中的主要功能： Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions; 在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中; 然后 Mutations 就去改变（Mutate）State 中的数据; 当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。 （2）各模块在核心流程中的主要功能： Vue Components∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch∶操作行为触发方法，是唯一能执行action的方法。 actions∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步&#x2F;异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。 mutations∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。 总结： Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。 2. Vuex中action和mutation的区别mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数： 12345678910const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; state.count++ // 变更状态 &#125; &#125;&#125;) 当触发一个类型为 increment 的 mutation 时，需要调用此函数： 1store.commit(&#x27;increment&#x27;) 而Action类似于mutation，不同点在于： Action 可以包含任意异步操作。 Action 提交的是 mutation，而不是直接变更状态。 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&#x27;increment&#x27;) &#125; &#125;&#125;) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 所以，两者的不同点如下： Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。 Mutation：必须同步执行；Action：可以异步，但不能直接操作State。 在视图更新时，先触发actions，actions再触发mutation mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters 3. Vuex 和 localStorage 的区别（1）最重要的区别 vuex存储在内存中 localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快 （2）应用场景 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。 localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。 Vuex能做到数据的响应式，localstorage不能 （3）永久性 刷新页面时vuex存储的值会丢失，localstorage不会。 注意：对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。 4. Redux 和 Vuex 有什么区别，它们的共同思想（1）Redux 和 Vuex区别 Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可 Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可 Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染） 通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; （2）共同思想 单—的数据源 变化可以预测 本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案; 形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理; 5. 为什么要用 Vuex 或者 Redux由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。 所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的”视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。 另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。 6. Vuex有哪几种属性？有五种，分别是 State、 Getter、Mutation 、Action、 Module state &#x3D;&gt; 基本数据(数据源存放地) getters =&gt; 从基本数据派生出来的数据 mutations =&gt; 提交更改数据的方法，同步 actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。 modules =&gt; 模块化Vuex 7. Vuex和单纯的全局对象有什么区别？ Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。 8. 为什么 Vuex 的 mutation 中不能做异步操作？ Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。 9. Vuex的严格模式是什么,有什么作用，如何开启？在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 在Vuex.Store 构造器选项中开启,如下 123const store = new Vuex.Store(&#123; strict:true,&#125;) 10. 如何在组件中批量使用Vuex的getter属性使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中 123456import &#123;mapGetters&#125; from &#x27;vuex&#x27;export default&#123; computed:&#123; ...mapGetters([&#x27;total&#x27;,&#x27;discountTotal&#x27;]) &#125;&#125; 11. 如何在组件中重复使用Vuex的mutation使用mapMutations辅助函数,在组件中这么使用 123456import &#123; mapMutations &#125; from &#x27;vuex&#x27;methods:&#123; ...mapMutations(&#123; setNumber:&#x27;SET_NUMBER&#x27;, &#125;)&#125; 然后调用this.setNumber(10)相当调用this.$store.commit(‘SET_NUMBER’,10)","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.cicoding.com/tags/VUE/"},{"name":"Vuex","slug":"Vuex","permalink":"https://www.cicoding.com/tags/Vuex/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"VUE路由","slug":"vue-router","date":"2024-02-03T03:28:03.000Z","updated":"2024-02-03T02:35:52.930Z","comments":false,"path":"vue/vue-router/","link":"","permalink":"https://www.cicoding.com/vue/vue-router/","excerpt":"","text":"1. Vue-Router 的懒加载如何实现非懒加载： 123456import List from &#x27;@/components/list.vue&#x27;const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/list&#x27;, component: List &#125; ]&#125;) （1）方案一(常用)：使用箭头函数+import动态加载 123456const List = () =&gt; import(&#x27;@/components/list.vue&#x27;)const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/list&#x27;, component: List &#125; ]&#125;) （2）方案二：使用箭头函数+require动态加载 12345678const router = new Router(&#123; routes: [ &#123; path: &#x27;/list&#x27;, component: resolve =&gt; require([&#x27;@/components/list&#x27;], resolve) &#125; ]&#125;) （3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。 123456789101112// r就是resolveconst List = r =&gt; require.ensure([], () =&gt; r(require(&#x27;@/components/list&#x27;)), &#x27;list&#x27;);// 路由也是正常的写法 这种是官方推荐的写的 按模块划分懒加载 const router = new Router(&#123; routes: [ &#123; path: &#x27;/list&#x27;, component: List, name: &#x27;list&#x27; &#125; ]&#125;)) 2. 路由的hash和history模式的区别Vue-Router有两种模式：hash模式和history模式。默认的路由模式是hash模式。 hash模式 简介： hash模式是开发中默认的模式，它的URL带着一个#，例如：http://www.abc.com/#/vue，它的hash值就是#/vue。 特点：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。 原理： hash模式的主要原理就是onhashchange()事件： 1234window.onhashchange = function(event)&#123; console.log(event.oldURL, event.newURL); let hash = location.hash.slice(1);&#125; 使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。 history模式 简介： history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。 特点： 当使用history模式时，URL就像这样：http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。 API： history api可以分为两大部分，切换历史状态和修改历史状态： 修改历史状态：包括了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。 切换历史状态： 包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。 虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。 如果想要切换到history模式，就要进行以下配置（后端也要进行配置）： 1234const router = new VueRouter(&#123; mode: &#x27;history&#x27;, routes: [...]&#125;) 两种模式对比 调用 history.pushState() 相比于直接修改 hash，存在以下优势: pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL； pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中； pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串； pushState() 可额外设置 title 属性供后续使用。 hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。 hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。 3. 如何获取页面的hash变化（1）监听$route的变化 12345678910// 监听,当路由发生变化的时候执行watch: &#123; $route: &#123; handler: function(val, oldVal)&#123; console.log(val); &#125;, // 深度观察监听 deep: true &#125;&#125;, （2）window.location.hash读取#值 window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。 4. $route 和$router 的区别 $route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。 5. 如何定义动态路由？如何获取传过来的动态参数？（1）param方式 配置路由格式：&#x2F;router&#x2F;:id 传递的方式：在path后面跟上对应的值 传递后形成的路径：&#x2F;router&#x2F;123 1）路由定义 12345678//在APP.vue中&lt;router-link :to=&quot;&#x27;/user/&#x27;+userId&quot; replace&gt;用户&lt;/router-link&gt; //在index.js&#123; path: &#x27;/user/:userid&#x27;, component: User,&#125;, 2）路由跳转 12345678// 方法1：&lt;router-link :to=&quot;&#123; name: &#x27;users&#x27;, params: &#123; uname: wade &#125;&#125;&quot;&gt;按钮&lt;/router-link // 方法2：this.$router.push(&#123;name:&#x27;users&#x27;,params:&#123;uname:wade&#125;&#125;) // 方法3：this.$router.push(&#x27;/user/&#x27; + wade) 3）参数获取 通过 $route.params.userid 获取传递的值 （2）query方式 配置路由格式：&#x2F;router，也就是普通配置 传递的方式：对象中使用query的key作为传递方式 传递后形成的路径：&#x2F;route?id&#x3D;123 1）路由定义 12345678910111213141516//方式1：直接在router-link 标签上以对象的形式&lt;router-link :to=&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;why&#x27;,age:28,height:188&#125;&#125;&quot;&gt;档案&lt;/router-link&gt; // 方式2：写成按钮以点击事件形式&lt;button @click=&#x27;profileClick&#x27;&gt;我的&lt;/button&gt; profileClick()&#123; this.$router.push(&#123; path: &quot;/profile&quot;, query: &#123; name: &quot;kobi&quot;, age: &quot;28&quot;, height: 198 &#125; &#125;);&#125; 2）跳转方法 1234567891011121314// 方法1：&lt;router-link :to=&quot;&#123; name: &#x27;users&#x27;, query: &#123; uname: james &#125;&#125;&quot;&gt;按钮&lt;/router-link&gt; // 方法2：this.$router.push(&#123; name: &#x27;users&#x27;, query:&#123; uname:james &#125;&#125;) // 方法3：&lt;router-link :to=&quot;&#123; path: &#x27;/user&#x27;, query: &#123; uname:james &#125;&#125;&quot;&gt;按钮&lt;/router-link&gt; // 方法4：this.$router.push(&#123; path: &#x27;/user&#x27;, query:&#123; uname:james &#125;&#125;) // 方法5：this.$router.push(&#x27;/user?uname=&#x27; + jsmes) 3）获取参数 1通过$route.query 获取传递的值 6. Vue-router 路由钩子在生命周期的体现一、Vue-Router导航守卫 有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的 全局路由钩子 全局有三个路由钩子; · router.beforeEach 全局前置守卫 进入路由之前 · router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用 · router.afterEach 全局后置钩子 进入路由之后 具体使用∶ · beforeEach（判断是否登录了，没登录就跳转到登录页） 12345678910111213141516router.beforeEach((to, from, next) =&gt; &#123; let ifInfo = Vue.prototype.$common.getSession(&#x27;userData&#x27;); // 判断是否登录的存储信息 if (!ifInfo) &#123; // sessionStorage里没有储存user信息 if (to.path == &#x27;/&#x27;) &#123; //如果是登录页面路径，就直接next() next(); &#125; else &#123; //不然就跳转到登录 Message.warning(&quot;请重新登录！&quot;); window.location.href = Vue.prototype.$loginUrl; &#125; &#125; else &#123; return next(); &#125;&#125;) · afterEach （跳转之后滚动条回到顶部） 1234router.afterEach((to, from) =&gt; &#123; // 跳转之后滚动条回到顶部 window.scrollTo(0,0);&#125;); 单个路由独享钩子 beforeEnter 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next 1234567891011export default [ &#123; path: &#x27;/&#x27;, name: &#x27;login&#x27;, component: login, beforeEnter: (to, from, next) =&gt; &#123; console.log(&#x27;即将进入登录页面&#x27;) next() &#125; &#125;] 组件内钩子 beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave 这三个钩子都有三个参数∶to、from、next beforeRouteEnter∶ 进入组件前触发 beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo&#x2F;∶id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用 beforeRouteLeave∶ 离开组件被调用 注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如： 1234567beforeRouteEnter(to, from, next) &#123; next(target =&gt; &#123; if (from.path == &#x27;/classProcess&#x27;) &#123; target.isFromProcess = true &#125; &#125;) &#125; 二、Vue路由钩子在生命周期函数的体现 完整的路由导航解析流程（不包括其他生命周期） 触发进入其他路由。 调用要离开路由的组件守卫beforeRouteLeave 调用局前置守卫∶ beforeEach 在重用的组件里调用 beforeRouteUpdate 调用路由独享守卫 beforeEnter。 解析异步路由组件。 在将要进入的路由组件中调用 beforeRouteEnter 调用全局解析守卫 beforeResolve 导航被确认。 调用全局后置钩子的 afterEach 钩子。 触发DOM更新（mounted）。 执行beforeRouteEnter 守卫中传给 next 的回调函数 触发钩子的完整顺序 路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶ beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。 beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。 beforeEnter：路由独享守卫 beforeRouteEnter：路由组件的组件进入路由前钩子。 beforeResolve：路由全局解析守卫 afterEach：路由全局后置钩子 beforeCreate：组件生命周期，不能访问tAis。 created;组件生命周期，可以访问tAis，不能访问dom。 beforeMount：组件生命周期 deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。 mounted：访问&#x2F;操作dom。 activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。 执行beforeRouteEnter回调函数next。 导航行为被触发到导航完成的整个过程 导航行为被触发，此时导航未被确认。 在失活的组件里调用离开守卫 beforeRouteLeave。 调用全局的 beforeEach守卫。 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。 在路由配置里调用 beforeEnteY。 解析异步路由组件（如果有）。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。 导航被确认。 调用全局的 afterEach 钩子。 非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。 导航完成 7. Vue-router跳转和location.href有什么区别 使用 location.href&#x3D; &#x2F;url 来跳转，简单方便，但是刷新了页面； 使用 history.pushState( &#x2F;url ) ，无刷新页面，静态跳转； 引进 router ，然后使用 router.push( &#x2F;url ) 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为vue-router就是用了 history.pushState() ，尤其是在history模式下。 8. params和query的区别用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.query.name 和 this.$route.params.name 。 url地址显示：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示 注意：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。 9. Vue-router 导航守卫有哪些 全局前置&#x2F;钩子：beforeEach、beforeResolve、afterEach 路由独享的守卫：beforeEnter 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave 10. 对前端路由的理解在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。 后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 SPA（单页面应用）。 SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题： SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。 由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息 为了解决这个问题，前端路由出现了。 前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。 那么如何实现这个目的呢？首先要解决两个问题： 当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。 单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？ 从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路： 拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。 感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.cicoding.com/tags/VUE/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"VUE组件通信","slug":"vue-components-communication","date":"2024-02-03T02:28:03.000Z","updated":"2024-02-03T02:13:50.558Z","comments":false,"path":"vue/vue-components-communication/","link":"","permalink":"https://www.cicoding.com/vue/vue-components-communication/","excerpt":"","text":"组件通信的方式如下： （1） props &#x2F; $emit父组件通过props向子组件传递数据，子组件通过$emit和父组件通信 父组件向子组件传值 props只能是父组件向子组件进行传值，props使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。 props 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。 props属性名规则：若在props中使用驼峰形式，模板中需要使用短横线的形式 123456789101112131415161718192021222324// 父组件&lt;template&gt; &lt;div id=&quot;father&quot;&gt; &lt;son :msg=&quot;msgData&quot; :fn=&quot;myFunction&quot;&gt;&lt;/son&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import son from &quot;./son.vue&quot;;export default &#123; name: father, data() &#123; msgData: &quot;父组件数据&quot;; &#125;, methods: &#123; myFunction() &#123; console.log(&quot;vue&quot;); &#125; &#125;, components: &#123; son &#125;&#125;;&lt;/script&gt; 12345678910111213// 子组件&lt;template&gt; &lt;div id=&quot;son&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;fn&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;son&quot;, props: [&quot;msg&quot;, &quot;fn&quot;]&#125;;&lt;/script&gt; 子组件向父组件传值 $emit绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过v-on监听并接收参数。 1234567891011121314151617181920212223242526// 父组件&lt;template&gt; &lt;div class=&quot;section&quot;&gt; &lt;com-article :articles=&quot;articleList&quot; @onEmitIndex=&quot;onEmitIndex&quot;&gt;&lt;/com-article&gt; &lt;p&gt;&#123;&#123;currentIndex&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import comArticle from &#x27;./test/article.vue&#x27;export default &#123; name: &#x27;comArticle&#x27;, components: &#123; comArticle &#125;, data() &#123; return &#123; currentIndex: -1, articleList: [&#x27;红楼梦&#x27;, &#x27;西游记&#x27;, &#x27;三国演义&#x27;] &#125; &#125;, methods: &#123; onEmitIndex(idx) &#123; this.currentIndex = idx &#125; &#125;&#125;&lt;/script&gt; 1234567891011121314151617//子组件&lt;template&gt; &lt;div&gt; &lt;div v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot; @click=&quot;emitIndex(index)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; props: [&#x27;articles&#x27;], methods: &#123; emitIndex(index) &#123; this.$emit(&#x27;onEmitIndex&#x27;, index) // 触发父组件的方法，并传递参数index &#125; &#125;&#125;&lt;/script&gt; （2）eventBus事件总线（$emit &#x2F; $on）eventBus事件总线适用于父子组件、非父子组件等之间的通信，使用步骤如下： （1）创建事件中心管理组件之间的通信 1234// event-bus.js import Vue from &#x27;vue&#x27;export const EventBus = new Vue() （2）发送事件 假设有两个兄弟组件firstCom和secondCom： 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;first-com&gt;&lt;/first-com&gt; &lt;second-com&gt;&lt;/second-com&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import firstCom from &#x27;./firstCom.vue&#x27;import secondCom from &#x27;./secondCom.vue&#x27;export default &#123; components: &#123; firstCom, secondCom &#125;&#125;&lt;/script&gt; 在firstCom组件中发送事件： 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;add&quot;&gt;加法&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import &#123;EventBus&#125; from &#x27;./event-bus.js&#x27; // 引入事件中心 export default &#123; data()&#123; return&#123; num:0 &#125; &#125;, methods:&#123; add()&#123; EventBus.$emit(&#x27;addition&#x27;, &#123; num:this.num++ &#125;) &#125; &#125;&#125;&lt;/script&gt; （3）接收事件 在secondCom组件中发送事件： 12345678910111213141516171819&lt;template&gt; &lt;div&gt;求和: &#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;/template&gt; &lt;script&gt;import &#123; EventBus &#125; from &#x27;./event-bus.js&#x27;export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;, mounted() &#123; EventBus.$on(&#x27;addition&#x27;, param =&gt; &#123; this.count = this.count + param.num; &#125;) &#125;&#125;&lt;/script&gt; 在上述代码中，这就相当于将num值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。 虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。 （3）依赖注入（provide&#x2F; inject）这种方式就是Vue中的依赖注入，该方法用于父子组件之间的通信。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。 provide &#x2F; inject是Vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。 provide 钩子用来发送数据或方法 inject钩子用来接收数据或方法 在父组件中： 12345provide() &#123; return &#123; num: this.num &#125;;&#125; 在子组件中： 1inject: [&#x27;num&#x27;] 还可以这样写，这样写就可以访问父组件中的所有属性： 12345678910111213provide() &#123; return &#123; app: this &#125;;&#125;data() &#123; return &#123; num: 1 &#125;;&#125; inject: [&#x27;app&#x27;]console.log(this.app.num) 注意： 依赖注入所提供的属性是非响应式的。 （3）ref &#x2F; $refs这种方式也是实现父子组件之间的通信。 ref： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。 在子组件中： 123456789101112export default &#123; data () &#123; return &#123; name: &#x27;JavaScript&#x27; &#125; &#125;, methods: &#123; sayHello () &#123; console.log(&#x27;hello&#x27;) &#125; &#125;&#125; 在父组件中： 12345678910111213&lt;template&gt; &lt;child ref=&quot;child&quot;&gt;&lt;/component-a&gt;&lt;/template&gt;&lt;script&gt; import child from &#x27;./child.vue&#x27; export default &#123; components: &#123; child &#125;, mounted () &#123; console.log(this.$refs.child.name); // JavaScript this.$refs.child.sayHello(); // hello &#125; &#125;&lt;/script&gt; （4）$parent &#x2F; $children 使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法） 使用$children可以让组件访问子组件的实例，但是，$children并不能保证顺序，并且访问的数据也不是响应式的。 在子组件中： 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;p&gt;获取父组件的值为: &#123;&#123;parentVal&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; data() &#123; return &#123; message: &#x27;Vue&#x27; &#125; &#125;, computed:&#123; parentVal()&#123; return this.$parent.msg; &#125; &#125;&#125;&lt;/script&gt; 在父组件中： 1234567891011121314151617181920212223242526// 父组件中&lt;template&gt; &lt;div class=&quot;hello_world&quot;&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;child&gt;&lt;/child&gt; &lt;button @click=&quot;change&quot;&gt;点击改变子组件值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import child from &#x27;./child.vue&#x27;export default &#123; components: &#123; child &#125;, data() &#123; return &#123; msg: &#x27;Welcome&#x27; &#125; &#125;, methods: &#123; change() &#123; // 获取到子组件 this.$children[0].message = &#x27;JavaScript&#x27; &#125; &#125;&#125;&lt;/script&gt; 在上面的代码中，子组件获取到了父组件的parentVal值，父组件改变了子组件中message的值。 需要注意： 通过$parent访问到的是上一级父组件的实例，可以使用$root来访问根组件的实例 在组件中使用$children拿到的是所有的子组件的实例，它是一个数组，并且是无序的 在根组件#app上拿$parent得到的是new Vue()的实例，在这实例上再拿$parent得到的是undefined，而在最底层的子组件拿$children是个空数组 $children 的值是数组，而$parent是个对象 （5）$attrs &#x2F; $listeners考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？ 如果是用props&#x2F;$emit来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。 针对上述情况，Vue引入了$attrs &#x2F; $listeners，实现组件之间的跨代通信。 先来看一下inheritAttrs，它的默认值true，继承所有的父组件属性除props之外的所有属性；inheritAttrs：false 只继承class属性 。 $attrs：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上 $listeners：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 v-on&#x3D;”$listeners” 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件） A组件（APP.vue）： 1234567891011121314151617181920&lt;template&gt; &lt;div id=&quot;app&quot;&gt; //此处监听了两个事件，可以在B组件或者C组件中直接触发 &lt;child1 :p-child1=&quot;child1&quot; :p-child2=&quot;child2&quot; @test1=&quot;onTest1&quot; @test2=&quot;onTest2&quot;&gt;&lt;/child1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child1 from &#x27;./Child1.vue&#x27;;export default &#123; components: &#123; Child1 &#125;, methods: &#123; onTest1() &#123; console.log(&#x27;test1 running&#x27;); &#125;, onTest2() &#123; console.log(&#x27;test2 running&#x27;); &#125; &#125;&#125;;&lt;/script&gt; B组件（Child1.vue）： 123456789101112131415161718&lt;template&gt; &lt;div class=&quot;child-1&quot;&gt; &lt;p&gt;props: &#123;&#123;pChild1&#125;&#125;&lt;/p&gt; &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt; &lt;child2 v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/child2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child2 from &#x27;./Child2.vue&#x27;;export default &#123; props: [&#x27;pChild1&#x27;], components: &#123; Child2 &#125;, inheritAttrs: false, mounted() &#123; this.$emit(&#x27;test1&#x27;); // 触发APP.vue中的test1方法 &#125;&#125;;&lt;/script&gt; C 组件 (Child2.vue)： 123456789101112131415&lt;template&gt; &lt;div class=&quot;child-2&quot;&gt; &lt;p&gt;props: &#123;&#123;pChild2&#125;&#125;&lt;/p&gt; &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: [&#x27;pChild2&#x27;], inheritAttrs: false, mounted() &#123; this.$emit(&#x27;test2&#x27;);// 触发APP.vue中的test2方法 &#125;&#125;;&lt;/script&gt; 在上述代码中： C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 在B组件中通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的） （6）总结（1）父子组件间通信 子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。 通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。 使用 provide&#x2F;inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。 （2）兄弟组件间通信 使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。 通过 $parent&#x2F;$refs 来获取到兄弟组件，也可以进行通信。 （3）任意组件之间 使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。 如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.cicoding.com/tags/VUE/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"VUE声明周期","slug":"vue-life-cycle","date":"2024-02-03T01:28:03.000Z","updated":"2024-02-03T02:10:11.653Z","comments":false,"path":"vue/vue-life-cycle/","link":"","permalink":"https://www.cicoding.com/vue/vue-life-cycle/","excerpt":"","text":"1. 说一下Vue的生命周期Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。 beforeCreate（创建前）：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event&#x2F;watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。 created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。 beforeMount（挂载前）：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。 mounted（挂载后）：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。 beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。 updated（更新后） ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。 destroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。 另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。 2. Vue 子组件和父组件执行顺序加载渲染过程： 父组件 beforeCreate 父组件 created 父组件 beforeMount 子组件 beforeCreate 子组件 created 子组件 beforeMount 子组件 mounted 父组件 mounted 更新过程： 父组件 beforeUpdate 子组件 beforeUpdate 子组件 updated 父组件 updated 销毁过程： 父组件 beforeDestroy 子组件 beforeDestroy 子组件 destroyed 父组件 destoryed 3. created和mounted的区别 created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。 mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。 4. 一般在哪个生命周期请求异步数据我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面加载时间，用户体验更好； SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。 5. keep-alive 中的生命周期哪些keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。 如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。 当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.cicoding.com/tags/VUE/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"VUE基础面试题","slug":"vue-foundation","date":"2024-02-02T13:28:03.000Z","updated":"2024-03-01T02:12:12.368Z","comments":false,"path":"vue/vue-foundation/","link":"","permalink":"https://www.cicoding.com/vue/vue-foundation/","excerpt":"","text":"1. Vue的基本原理当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter&#x2F;setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。 2. 双向数据绑定的原理Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤： 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。 在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。 4. MVVM、MVC、MVP的区别MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。 在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。 （1）MVC MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 （2）MVVM MVVM 分为 Model、View、ViewModel： Model代表数据模型，数据和业务逻辑都在Model层中定义； View代表UI视图，负责数据的展示； ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作； Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。 这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。 （3）MVP MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。 5. Computed 和 Watch 的区别对于Computed： 它支持缓存，只有依赖的数据发生了变化，才会重新计算 不支持异步，当Computed中有异步操作时，无法监听数据的变化 computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的 如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed 如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。 对于Watch： 它不支持缓存，数据变化时，它就会触发相应的操作 支持异步监听 监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值 当一个属性发生变化时，就需要执行相应的操作 监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数： immediate：组件加载立即触发回调函数 deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。 当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。 总结： computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。 运用场景： 当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。 当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 6. Computed 和 Methods 的区别可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的 不同点： computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值； method 调用总会执行该函数。 7. slot是什么？有什么作用？原理是什么？slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。 默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。 具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。 作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。 实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。 8. 过滤器的作用，如何实现一个过滤器根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用filters来过滤数据，filters不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。 使用场景： 需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出显示。 比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。 过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式&#123;&#123;&#125;&#125;和 v-bind 表达式 中，然后放在操作符|后面进行指示。 9. 如何保存页面的当前的状态既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况： 前组件会被卸载 前组件不会被卸载 那么可以按照这两种情况分别得到以下方法： 组件会被卸载： （1）将状态存储在LocalStorage &#x2F; SessionStorage 只需要在组件即将被销毁的生命周期中在 LocalStorage &#x2F; SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。 比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。 优点 兼容性好，不需要额外库或工具。 简单快捷，基本可以满足大部分需求。 缺点 状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点） 如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象 （2）路由传值 通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。 在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。 优点 简单快捷，不会污染 LocalStorage &#x2F; SessionStorage。 可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify &#x2F; parse 的不足） 缺点 如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。 组件不会被卸载： （1）单页面渲染 要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。 优点 代码量少 不需要考虑状态传递过程中的错误 缺点 增加 A 组件维护成本 需要传入额外的 prop 到 B 组件 无法利用路由定位页面 除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留： 123&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/kepp-alive&gt; router.js 12345678&#123; path: &#x27;/&#x27;, name: &#x27;xxx&#x27;, component: ()=&gt;import(&#x27;../src/views/xxx.vue&#x27;), meta:&#123; keepAlive: true // 需要被缓存 &#125;&#125;, 10. 常见的事件修饰符及其作用 stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡； prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）； capture ：与事件冒泡的方向相反，事件捕获由外到内； self ：只会触发自己范围内的事件，不包含子元素； once ：只会触发一次。 11. v-if、v-show、v-html 的原理 v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染； v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display； v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。 13.v-if和v-show的区别 手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐； 编译过程：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换； 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留； 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗； 使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。 14.v-model 是如何实现的，语法糖实际是什么？（1）作用在表单元素上 动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值： 1234567891011&lt;input v-model=&quot;sth&quot; /&gt;// 等同于&lt;input v-bind:value=&quot;message&quot; v-on:input=&quot;message=$event.target.value&quot;&gt; //$event 指代当前触发的事件对象;//$event.target 指代当前触发的事件对象的dom;//$event.target.value 就是当前dom的value值;//在@input方法中，value =&gt; sth;//在:value中,sth =&gt; value; （2）作用在组件上 在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件 本质是一个父子组件通信的语法糖，通过prop和$.emit实现。因此父组件 v-model 语法糖本质上可以修改为： 1&lt;child :value=&quot;message&quot; @input=&quot;function(e)&#123;message = e&#125;&quot;&gt;&lt;/child&gt; 在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。 例子： 1234567891011121314// 父组件&lt;aa-input v-model=&quot;aa&quot;&gt;&lt;/aa-input&gt;// 等价于&lt;aa-input v-bind:value=&quot;aa&quot; v-on:input=&quot;aa=$event.target.value&quot;&gt;&lt;/aa-input&gt; // 子组件：&lt;input v-bind:value=&quot;aa&quot; v-on:input=&quot;onmessage&quot;&gt;&lt;/aa-input&gt; props:&#123;value:aa,&#125;methods:&#123; onmessage(e)&#123; $emit(&#x27;input&#x27;,e.target.value) &#125;&#125; 默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input $emit过来的值。 15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？可以。v-model 实际上是一个语法糖，如： 1&lt;input v-model=&quot;searchText&quot;&gt; 实际上相当于： 1234&lt;input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event.target.value&quot;&gt; 用在自定义组件上也是同理： 1&lt;custom-input v-model=&quot;searchText&quot;&gt; 相当于： 1234&lt;custom-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot;&gt;&lt;/custom-input&gt; 显然，custom-input 与父组件的交互如下： 父组件将searchText变量传入custom-input 组件，使用的 prop 名为value； custom-input 组件向父组件传出名为input的事件，父组件将接收到的值赋值给searchText； 所以，custom-input 组件的实现应该类似于这样： 123456789Vue.component(&#x27;custom-input&#x27;, &#123; props: [&#x27;value&#x27;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot; &gt; `&#125;) 16. data为什么是一个函数而不是对象Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。 17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。 （1）keep-alive keep-alive有以下三个属性： include 字符串或正则表达式，只有名称匹配的组件会被匹配； exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存； max 数字，最多可以缓存多少组件实例。 注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。 主要流程 判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。 获取组件实例 key ，如果有获取实例的 key，否则重新生成。 key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。 如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。 （2）keep-alive 的实现 123456789101112131415161718192021222324252627282930313233343536const patternTypes: Array&lt;Function&gt; = [String, RegExp, Array] // 接收：字符串，正则，数组 export default &#123; name: &#x27;keep-alive&#x27;, abstract: true, // 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 props: &#123; include: patternTypes, // 匹配的组件，缓存 exclude: patternTypes, // 不去匹配的组件，不缓存 max: [String, Number], // 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限 &#125;, created() &#123; // 用于初始化缓存虚拟DOM数组和vnode的key this.cache = Object.create(null) this.keys = [] &#125;, destroyed() &#123; // 销毁缓存cache的组件实例 for (const key in this.cache) &#123; pruneCacheEntry(this.cache, key, this.keys) &#125; &#125;, mounted() &#123; // prune 削减精简[v.] // 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容 this.$watch(&#x27;include&#x27;, (val) =&gt; &#123; pruneCache(this, (name) =&gt; matches(val, name)) &#125;) this.$watch(&#x27;exclude&#x27;, (val) =&gt; &#123; pruneCache(this, (name) =&gt; !matches(val, name)) &#125;) &#125;,&#125; render函数： 会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件 keep-alive 只对第一个组件有效，所以获取第一个子组件。 和 keep-alive 搭配使用的一般有：动态组件 和router-view 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162render () &#123; // function getFirstComponentChild (children: ?Array&lt;VNode&gt;): ?VNode &#123; if (Array.isArray(children)) &#123; for (let i = 0; i &lt; children.length; i++) &#123; const c = children[i] if (isDef(c) &amp;&amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) &#123; return c &#125; &#125; &#125; &#125; const slot = this.$slots.default // 获取默认插槽 const vnode: VNode = getFirstComponentChild(slot)// 获取第一个子组件 const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions // 组件参数 if (componentOptions) &#123; // 是否有组件参数 // check pattern const name: ?string = getComponentName(componentOptions) // 获取组件名 const &#123; include, exclude &#125; = this if ( // not included (include &amp;&amp; (!name || !matches(include, name))) || // excluded (exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) ) &#123; // 如果不匹配当前组件的名字和include以及exclude // 那么直接返回组件的实例 return vnode &#125; const &#123; cache, keys &#125; = this // 获取这个组件的key const key: ?string = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;) : vnode.key if (cache[key]) &#123; // LRU缓存策略执行 vnode.componentInstance = cache[key].componentInstance // 组件初次渲染的时候componentInstance为undefined // make current key freshest remove(keys, key) keys.push(key) // 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面 &#125; else &#123; // 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除 // 使用时间间隔最长的一个 cache[key] = vnode keys.push(key) // prune oldest entry if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; pruneCacheEntry(cache, keys[0], keys, this._vnode) &#125; &#125; // 将组件的keepAlive属性设置为true vnode.data.keepAlive = true // 作用：判断是否要执行组件的created、mounted生命周期函数 &#125; return vnode || (slot &amp;&amp; slot[0])&#125; keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。 实现步骤： 获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名 通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode 需要缓存，判断他当前是否在缓存数组里面： 存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU） 不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key 最后将这个组件的 keepAlive 设置为 true （3）keep-alive 本身的创建过程和 patch 过程 缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。 首次渲染 组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM 1234567891011121314151617181920212223242526// core/instance/lifecyclefunction initLifecycle (vm: Component) &#123; const options = vm.$options // locate first non-abstract parent let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; // 判断组件的abstract属性，才往父组件里面挂载DOM while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false&#125; 判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance 123456789101112131415161718// core/vdom/create-componentinit (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123; if ( vnode.componentInstance &amp;&amp; !vnode.componentInstance._isDestroyed &amp;&amp; vnode.data.keepAlive ) &#123; // componentInstance在初次是undefined!!! // kept-alive components, treat as a patch const mountedNode: any = vnode // work around flow componentVNodeHooks.prepatch(mountedNode, mountedNode) // prepatch函数执行的是组件更新的过程 &#125; else &#123; const child = vnode.componentInstance = createComponentInstanceForVnode( vnode, activeInstance ) child.$mount(hydrating ? vnode.elm : undefined, hydrating) &#125; &#125;, prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入 （4）LRU （least recently used）缓存策略 LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是”如果数据最近被访问过，那么将来被访问的几率也更高”。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶ 新数据插入到链表头部 每当缓存命中（即缓存数据被访问），则将数据移到链表头部 链表满的时候，将链表尾部的数据丢弃。 18. $nextTick 原理及作用Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。 nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微&#x2F;宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。 nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理 nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶ 如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI&#x2F;DOM 的渲染，可以减少一些无用渲染 同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要 Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。 由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。 123this.$nextTick(() =&gt; &#123; // 获取数据的操作...&#125;) 所以，在以下情况下，会用到nextTick： 在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。 在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。 因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。 19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;value in obj&quot; :key=&quot;value&quot;&gt; &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;addObjB&quot;&gt;添加 obj.b&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; obj: &#123; a: &#x27;obj.a&#x27; &#125; &#125; &#125;, methods: &#123; addObjB () &#123; this.obj.b = &#x27;obj.b&#x27; console.log(this.obj) &#125; &#125; &#125;&lt;/script&gt; 点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()： 1234addObjB () ( this.$set(this.obj, &#x27;b&#x27;, &#x27;obj.b&#x27;) console.log(this.obj)&#125; $set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。 20. Vue中封装的数组方法有哪些，其如何实现页面更新在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。 那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 缓存数组原型const arrayProto = Array.prototype;// 实现 arrayMethods.__proto__ === Array.prototypeexport const arrayMethods = Object.create(arrayProto);// 需要进行功能拓展的方法const methodsToPatch = [ &quot;push&quot;, &quot;pop&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;reverse&quot;]; /** * Intercept mutating methods and emit events */methodsToPatch.forEach(function(method) &#123; // 缓存原生数组方法 const original = arrayProto[method]; def(arrayMethods, method, function mutator(...args) &#123; // 执行并缓存原生数组功能 const result = original.apply(this, args); // 响应式处理 const ob = this.__ob__; let inserted; switch (method) &#123; // push、unshift会新增索引，所以要手动observer case &quot;push&quot;: case &quot;unshift&quot;: inserted = args; break; // splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。 case &quot;splice&quot;: inserted = args.slice(2); break; &#125; // if (inserted) ob.observeArray(inserted);// 获取插入的值，并设置响应式监听 // notify change ob.dep.notify();// 通知依赖更新 // 返回原生数组方法的执行结果 return result; &#125;);&#125;); 简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过target__proto__ &#x3D;&#x3D; arrayMethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。 21. Vue 单页应用与多页应用的区别概念： SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。 MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。 区别： 22. Vue template 到 render 的过程vue的模版编译过程主要如下：template -&gt; ast -&gt; render函数 vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数： 12// 将模板编译为render函数const &#123; render, staticRenderFns &#125; = compileToFunctions(template,options//省略&#125;, this) CompileToFunctions中的主要逻辑如下∶ （1）调用parse方法将template转化为ast（抽象语法树） 1constast = parse(template.trim(), options) parse的目标：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。 解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。 AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本 （2）对静态节点做优化 1optimize(ast,options) 这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化 深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。 （3）生成代码 1const code = generate(ast, options) generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 new Function( render) 生成render函数。 23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。 如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。 24. 简述 mixin、extends 的覆盖逻辑（1）mixin 和 extends mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。 mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。 extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。 （2）mergeOptions 的执行过程 · 规范化选项（normalizeProps、normalizelnject、normalizeDirectives) · 对未合并的选项，进行判断 12345678910if(!child._base) &#123; if(child.extends) &#123; parent = mergeOptions(parent, child.extends, vm) &#125; if(child.mixins) &#123; for(let i = 0, l = child.mixins.length; i &lt; l; i++)&#123; parent = mergeOptions(parent, child.mixins[i], vm) &#125; &#125;&#125; 合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。 返回合并结果 options。 25. 描述下Vue自定义指令在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据; （1）自定义指令基本内容 全局定义：Vue.directive(“focus”,{}) 局部定义：directives:{focus:{}} 钩子函数：指令定义对象提供钩子函数 bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。 update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。 ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数参数 el：绑定元素 bing： 指令核心对象，描述指令全部信息属性 name value oldValue expression arg modifers vnode 虚拟节点 oldVnode：上一个虚拟节点（更新钩子函数中才有用） （2）使用场景 普通DOM元素进行底层操作的时候，可以使用自定义指令 自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。 （3）使用案例 初级应用： 鼠标聚焦 下拉菜单 相对时间转换 滚动动画 高级应用： 自定义指令实现图片懒加载 自定义指令集成第三方插件 26. 子组件可以直接改变父组件的数据吗？​ 子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。 ​ Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。 ​ 只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 27. Vue是如何收集依赖的？在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶ 123456789101112131415function defieneReactive (obj, key, val)&#123; const dep = new Dep(); ... Object.defineProperty(obj, key, &#123; ... get: function reactiveGetter () &#123; if(Dep.target)&#123; dep.depend(); ... &#125; return val &#125; ... &#125;)&#125; 以上只保留了关键代码，主要就是 const dep &#x3D; new Dep()实例化一个 Dep 的实例，然后在 get 函数中通过 dep.depend() 进行依赖收集。 （1）Dep Dep是整个依赖收集的核心，其关键代码如下： 1234567891011121314151617181920212223242526class Dep &#123; static target; subs; constructor () &#123; ... this.subs = []; &#125; addSub (sub) &#123; this.subs.push(sub) &#125; removeSub (sub) &#123; remove(this.sub, sub) &#125; depend () &#123; if(Dep.target)&#123; Dep.target.addDep(this) &#125; &#125; notify () &#123; const subs = this.subds.slice(); for(let i = 0;i &lt; subs.length; i++)&#123; subs[i].update() &#125; &#125;&#125; Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶ （2）Watcher 1234567891011121314151617181920212223class Watcher &#123; getter; ... constructor (vm, expression)&#123; ... this.getter = expression; this.get(); &#125; get () &#123; pushTarget(this); value = this.getter.call(vm, vm) ... return value &#125; addDep (dep)&#123; ... dep.addSub(this) &#125; ...&#125;function pushTarget (_target) &#123; Dep.target = _target&#125; Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。 （3）过程 在实例化 Vue 时，依赖收集的相关过程如下∶ 初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。 初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法， 1234updateComponent = () =&gt; &#123; vm._update(vm._render())&#125;new Watcher(vm, updateComponent) get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。 this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。 28. 对 React 和 Vue 的理解，它们的异同相似之处： 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库； 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板； 都使用了Virtual DOM（虚拟DOM）提高重绘性能； 都有props的概念，允许组件间的数据传递； 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。 不同之处 ： 1）数据流 Vue默认支持数据双向绑定，而React一直提倡单向数据流 2）虚拟DOM Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。 Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。 对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent&#x2F;shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。 3）组件化 React与Vue最大的不同是模板的编写。 Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。 React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。 具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。 4）监听数据变化的实现原理不同 Vue 通过 getter&#x2F;setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能 React 默认是通过比较引用的方式进行的，如果不优化（PureComponent&#x2F;shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。 5）高阶组件 react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。 高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。 6）构建工具 两者都有自己的构建工具： React &#x3D;&#x3D;&gt; Create React APP Vue &#x3D;&#x3D;&gt; vue-cli 7）跨平台 React &#x3D;&#x3D;&gt; React Native Vue &#x3D;&#x3D;&gt; Weex 29. Vue的优点 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ； 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习； 双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单； 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势； 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作； 虚拟DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式； 运行速度更快：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势。 30. assets和static的区别相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点 不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。 建议： 将项目中 template需要的样式文件js文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。 31. delete和Vue.delete删除数组的区别 delete 只是被删除的元素变成了 empty&#x2F;undefined 其他的元素的键值还是不变。 Vue.delete 直接删除了数组 改变了数组的键值。 32. vue如何监听对象或者数组某个属性的变化当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。 解决方式： this.$set(你要改变的数组&#x2F;对象，你要改变的位置&#x2F;key，你要改成什么value) 12this.$set(this.arr, 0, &quot;OBKoro1&quot;); // 改变数组this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象 调用以下几个数组的方法 1splice()、 push()、pop()、shift()、unshift()、sort()、reverse() vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除&#x2F;添加操作 vm.$set 的实现原理是： 如果目标是数组，直接使用数组的 splice 方法触发相应式； 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法） 33. 什么是 mixin ？ Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。 如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。 然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。 34. Vue模版编译原理vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。 解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。 优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。 生成阶段：将最终的AST转化为render函数字符串。 35. 对SSR的理解SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端 SSR的优势： 更好的SEO 首屏加载速度更快 SSR的缺点： 开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子； 当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境； 更多的服务端负载。 36. Vue的性能优化有哪些（1）编码阶段 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher v-if和v-for不能连用 如果需要使用v-for给每项元素绑定事件时使用事件代理 SPA 页面采用keep-alive缓存组件 在更多的情况下，使用v-if替代v-show key保证唯一 使用路由懒加载、异步组件 防抖、节流 第三方模块按需导入 长列表滚动到可视区域动态加载 图片懒加载 （2）SEO优化 预渲染 服务端渲染SSR （3）打包优化 压缩代码 Tree Shaking&#x2F;Scope Hoisting 使用cdn加载第三方模块 多线程打包happypack splitChunks抽离公共文件 sourceMap优化 （4）用户体验 骨架屏 PWA 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。 37. 对 SPA 单页面的理解，它的优缺点分别是什么？SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 38. template和jsx的有什么分别？对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。 所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。 39. vue初始化页面闪动问题使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。 首先：在css里加上以下代码： 123[v-cloak] &#123; display: none;&#125; 如果没有彻底解决问题，则在根元素加上style&#x3D;”display: none;” :style&#x3D;”{display: ‘block’}” 40. extend 有什么作用这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。 1234567891011121314// 创建组件构造器let Component = Vue.extend(&#123; template: &#x27;&lt;div&gt;test&lt;/div&gt;&#x27;&#125;)// 挂载到 #app 上new Component().$mount(&#x27;#app&#x27;)// 除了上面的方式，还可以用来扩展已有的组件let SuperComponent = Vue.extend(Component)new SuperComponent(&#123; created() &#123; console.log(1) &#125;&#125;)new SuperComponent().$mount(&#x27;#app&#x27;) 41. mixin 和 mixins 区别mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。 123456Vue.mixin(&#123; beforeCreate() &#123; // ...逻辑 // 这种方式会影响到每个组件的 beforeCreate 钩子函数 &#125;&#125;) 虽然文档不建议在应用中直接使用 mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 ajax 或者一些工具函数等等。 mixins 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。 另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。 42. MVVM的优缺点?优点: 分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑 提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码 ⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放 缺点: Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的 ⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存 对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。 43. v-if和v-for哪个优先级更高？如果同时出现，应如何优化？v-for优先于v-if被解析，如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能。 要避免出现这种情况，则在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项。 44. 对Vue组件化的理解 组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用； 组件化开发能大幅提高应用开发效率、测试性、复用性等； 组件使用按分类有：页面组件、业务组件、通用组件； vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展于Vue； vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；6.合理的划分组件，有助于提升应用性能； 组件应该是高内聚、低耦合的； 遵循单向数据流的原则。 45. 对vue设计原则的理解 渐进式JavaScript框架：与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。 易用性：vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。 灵活性：渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。 高效性：超快的虚拟DOM和diﬀ算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。 46. 常见的Vue性能优化方法 路由懒加载 1234const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/foo&#x27;, component: () =&gt; import(&#x27;./Foo.vue&#x27;) &#125; ]&#125;) keep-alive缓存页面 1234567&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view/&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 使用v-show复用DOM 1234567891011&lt;template&gt; &lt;div class=&quot;cell&quot;&gt; &lt;!--这种情况用v-show复用DOM，比v-if效果好--&gt; &lt;div v-show=&quot;value&quot; class=&quot;on&quot;&gt; &lt;Heavy :n=&quot;10000&quot;/&gt; &lt;/div&gt; &lt;section v-show=&quot;!value&quot; class=&quot;off&quot;&gt; &lt;Heavy :n=&quot;10000&quot;/&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt; v-for 遍历避免同时使用 v-if 12345678910111213141516171819&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;user in activeUsers&quot; :key=&quot;user.id&quot;&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; &lt;script&gt;export default &#123; computed: &#123; activeUsers: function () &#123; return this.users.filter(function (user) &#123; return user.isActive &#125;) &#125; &#125;&#125;&lt;/script&gt; 长列表性能优化 1234567891011121314151617// 如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化export default &#123; data: () =&gt; (&#123; users: [] &#125;), async created() &#123; const users = await axios.get(&quot;/api/users&quot;); this.users = Object.freeze(users); &#125; &#125;; // 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容&lt;recycle-scroller class=&quot;items&quot; :items=&quot;items&quot; :item-size=&quot;24&quot;&gt; &lt;template v-slot=&quot;&#123; item &#125;&quot;&gt; &lt;FetchItemView :item=&quot;item&quot; @vote=&quot;voteItem(item)&quot;/&gt; &lt;/template&gt;&lt;/recycle-scroller&gt; 事件的销毁 Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 123456created() &#123; this.timer = setInterval(this.refresh, 2000)&#125;,beforeDestroy() &#123; clearInterval(this.timer)&#125; 图片懒加载 对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。 1&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt; 第三方插件按需引入 像element-ui这样的第三方组件库可以按需引入避免体积太大。 12345import Vue from &#x27;vue&#x27;;import &#123; Button, Select &#125; from &#x27;element-ui&#x27;; Vue.use(Button) Vue.use(Select) 无状态的组件标记为函数式组件 1234567891011&lt;template functional&gt; &lt;div class=&quot;cell&quot;&gt; &lt;div v-if=&quot;props.value&quot; class=&quot;on&quot;&gt;&lt;/div&gt; &lt;section v-else class=&quot;off&quot;&gt;&lt;/section&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; props: [&#x27;value&#x27;] &#125;&lt;/script&gt; 子组件分隔 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;ChildComp/&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; components: &#123; ChildComp: &#123; methods: &#123; heavy () &#123; /* 耗时任务 */ &#125; &#125;, render (h) &#123; return h(&#x27;div&#x27;, this.heavy()) &#125; &#125; &#125; &#125;&lt;/script&gt; 变量本地化 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div :style=&quot;&#123; opacity: start / 300 &#125;&quot;&gt; &#123;&#123; result &#125;&#125; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import &#123; heavy &#125; from &#x27;@/utils&#x27; export default &#123; props: [&#x27;start&#x27;], computed: &#123; base () &#123; return 42 &#125;, result () &#123; const base = this.base // 不要频繁引用this.base let result = this.start for (let i = 0; i &lt; 1000; i++) &#123; result += heavy(base) &#125; return result &#125; &#125;&#125;&lt;/script&gt; SSR 47. v-model的实现原理vue中v-model可以实现数据的双向绑定，但是为什么这个指令就可以实现数据的双向绑定呢？其实v-model是vue的一个语法糖。即利用v-model绑定数据后，既绑定了数据，又添加了一个input事件监听。 实现原理： v-bind绑定响应数据 触发input事件并传递数据 示例： 123456789101112131415&lt;input v-model=&quot;text&quot;&gt;&lt;/input&gt;// 等价于：&lt;input :value=&quot;text&quot; @input=&quot;text = $event.target.value&quot;&gt;&lt;/input&gt;// 组件中使用：&lt;custom-input :value=&quot;text&quot; @input=&quot;$event&quot;&gt;&lt;/custom-input&gt;// 根据v-model原理模拟：&lt;input type=&quot;text&quot; id=&quot;ipt1&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;ipt2&quot;&gt;&lt;script&gt; var ipt1=document.getElementById(&#x27;ipt1&#x27;); var ipt2=document.getElementById(&#x27;ipt2&#x27;); ipt1.addEventListener(&quot;input&quot;,function()&#123; ipt2.value=ipt1.value; &#125;)&lt;/script&gt;","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.cicoding.com/tags/VUE/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"Redis面试","slug":"redis","date":"2023-07-13T14:28:03.000Z","updated":"2024-02-24T08:12:33.906Z","comments":false,"path":"redis/redis/","link":"","permalink":"https://www.cicoding.com/redis/redis/","excerpt":"","text":"Redis应用场景 top 列表产品运营总会让你展示最近、最热、点击率最高、活跃度最高等等条件的top list。很多更新较频繁的列表如果使用MC+MySQL维护的话缓存失效的可能性会比较大，鉴于占用内存较小的情况，使用Redis做存储也是相当不错的。 最后的访问用户最近访问记录也是redis list的很好应用场景，lpush lpop自动过期老的登陆记录，对于开发来说还是非常友好的 手机验证码的，有效时间 限制用户登录的次数，比如一天错误登录次数10次。 投票系统 ，投票结果排序。 排行榜等等 存储社交信息，set的并集和交集。比较两个用户的共同粉丝 各种计数：商品维度计数（点赞数，评论数，浏览数） 发布订阅，聊天室等","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.cicoding.com/tags/Redis/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"Nginx面试","slug":"nginx","date":"2023-07-13T14:28:03.000Z","updated":"2024-02-24T08:12:48.342Z","comments":false,"path":"nginx/nginx/","link":"","permalink":"https://www.cicoding.com/nginx/nginx/","excerpt":"","text":"什么是Nginx？Nginx是一个 轻量级&#x2F;高性能的反向代理Web服务器，用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。他实现非常高效的反向代理、负载平衡，他可以处理2-3万并发连接数，官方监测能支持5万并发，现在中国使用nginx网站用户有很多，例如：新浪、网易、 腾讯等。 Nginx 有哪些优点？ 跨平台、配置简单。 非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发。 内存消耗小：开启 10 个 Nginx 才占 150M 内存。 成本低廉，且开源。 稳定性高，宕机的概率非常小。 内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上 Nginx 应用场景？ http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会应为某台服务器负载高宕机而某台服务器闲置的情况。 nginz 中也可以配置安全管理、比如可以使用Nginx搭建API接口网关,对每个接口服务进行拦截。 Nginx 怎么处理请求的？1234567server &#123; # 第一个Server区块开始，表示一个独立的虚拟主机站点 listen 80；# 提供服务的端口，默认80 server_name localhost; # 提供服务的域名主机名 location / &#123; # 第一个location区块开始 root html; # 站点的根目录，相当于Nginx的安装目录 index index.html index.html; # 默认的首页文件，多个用空格分开&#125; # 第一个location区块结果 首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 IP 地址，然后在 Nginx 的 Master 进程里面先初始化好这个监控的Socket(创建 S ocket，设置 addr、reuse 等选项，绑定到指定的 ip 地址端口，再 listen 监听)。 然后，再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程 )出多个子进程出来。 之后，子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与nginx进行三次握手，与 nginx 建立好一个连接后。此时，某一个子进程会 accept 成功，得到这个建立好的连接的 Socket ，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体。 接着，设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换。 最后，Nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了。 Nginx 是如何实现高并发的？如果一个 server 采用一个进程(或者线程)负责一个request的方式，那么进程数就是并发数。那么显而易见的，就是会有很多进程在等待中。等什么？最多的应该是等待网络传输。而 Nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的时候，这些进程就空闲出来待命了。因此表现为少数几个进程就解决了大量的并发问题。Nginx是如何利用的呢，简单来说：同样的 4 个进程，如果采用一个进程负责一个 request 的方式，那么，同时进来 4 个 request 之后，每个进程就负责其中一个，直至会话关闭。期间，如果有第 5 个request进来了。就无法及时反应了，因为 4 个进程都没干完活呢，因此，一般有个调度进程，每当新进来了一个 request ，就新开个进程来处理。回想下，BIO 是不是存在酱紫的问题？Nginx 不这样，每进来一个 request ，会有一个 worker 进程去处理。但不是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方，比如向上游（后端）服务器转发 request ，并等待请求返回。那么，这个处理的 worker 不会这么傻等着，他会在发送完请求后，注册一个事件：“如果 upstream 返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有 request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker 才会来接手，这个 request 才会接着往下走。这就是为什么说，Nginx 基于事件模型。由于 web server 的工作性质决定了每个 request 的大部份生命都是在网络传输中，实际上花费在 server 机器上的时间片不多。这是几个进程就解决高并发的秘密所在。即：webserver 刚好属于网络 IO 密集型应用，不算是计算密集型。异步，非阻塞，使用 epoll ，和大量细节处的优化。也正是 Nginx 之所以然的技术基石。 什么是正向代理？一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。正向代理总结就一句话：代理端代理的是客户端。例如说：我们使用的OpenVPN 等等。 什么是反向代理？反向代理（Reverse Proxy）方式，是指以代理服务器来接受 Internet上的连接请求，然后将请求，发给内部网络上的服务器并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。反向代理总结就一句话：代理端代理的是服务端。 反向代理服务器的优点是什么?反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和web服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用web托管服务时。 Nginx 目录结构有哪些？1234567891011121314151617181920212223242526272829303132tree /usr/local/nginx/usr/local/nginx├── client_body_temp├── conf # Nginx所有配置文件的目录│ ├── fastcgi.conf # fastcgi相关参数的配置文件│ ├── fastcgi.conf.default # fastcgi.conf的原始备份文件│ ├── fastcgi_params # fastcgi的参数文件│ ├── fastcgi_params.default │ ├── koi-utf│ ├── koi-win│ ├── mime.types # 媒体类型│ ├── mime.types.default│ ├── nginx.conf # Nginx主配置文件│ ├── nginx.conf.default│ ├── scgi_params # scgi相关参数文件│ ├── scgi_params.default │ ├── uwsgi_params # uwsgi相关参数文件│ ├── uwsgi_params.default│ └── win-utf├── fastcgi_temp # fastcgi临时数据目录├── html # Nginx默认站点目录│ ├── 50x.html # 错误页面优雅替代显示文件，例如当出现502错误时会调用此页面│ └── index.html # 默认的首页文件├── logs # Nginx日志目录│ ├── access.log # 访问日志文件│ ├── error.log # 错误日志文件│ └── nginx.pid # pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件├── proxy_temp # 临时目录├── sbin # Nginx命令目录│ └── nginx # Nginx的启动命令├── scgi_temp # 临时目录└── uwsgi_temp # 临时目录 Nginx 配置文件 nginx.conf 有哪些属性模块?12345678910111213141516171819202122worker_processes 1；# worker进程的数量events &#123; # 事件区块开始 worker_connections 1024；# 每个worker进程支持的最大连接数&#125; # 事件区块结束http &#123; # HTTP区块开始 include mime.types；# Nginx支持的媒体类型库文件 default_type application/octet-stream；# 默认的媒体类型 sendfile on；# 开启高效传输模式 keepalive_timeout 65；# 连接超时 server &#123; # 第一个Server区块开始，表示一个独立的虚拟主机站点 listen 80；# 提供服务的端口，默认80 server_name localhost；# 提供服务的域名主机名 location / &#123; # 第一个location区块开始 root html；# 站点的根目录，相当于Nginx的安装目录 index index.html index.htm；# 默认的首页文件，多个用空格分开 &#125; # 第一个location区块结果 error_page 500502503504 /50x.html；# 出现对应的http状态码时，使用50x.html回应客户 location = /50x.html &#123; # location区块开始，访问50x.html root html；# 指定对应的站点目录为html &#125; &#125; ...... cookie 和 session 区别？共同：存放用户信息。存放的形式：key-value格式 变量和变量内容键值对。区别：cookie 存放在客户端浏览器 每个域名对应一个cookie，不能跨跃域名访问其他cookie 用户可以查看或修改cookie http响应报文里面给你浏览器设置 钥匙（用于打开浏览器上锁头）session: 存放在服务器（文件，数据库，redis） 存放敏感信息 锁头 为什么 Nginx 不使用多线程？Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以 worker 支持比 perfork 高的并发），并发过大会榨干服务器资源。Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置 Nginx 主进程的工作进程的数量）(epoll)，不会为每个请求分配 cpu 和内存资源，节省了大量资源，同时也减少了大量的 CPU 的上下文切换。所以才使得 Nginx 支持更高的并发。 nginx和apache的区别轻量级，同样起web服务，比apache占用更少的内存和资源。抗并发，nginx处理请求是异步非阻塞的，而apache则是阻塞性的，在高并发下nginx能保持低资源，低消耗高性能。高度模块化的设计，编写模块相对简单。最核心的区别在于apache是同步多进程模型，一个连接对应一个进程，nginx是异步的，多个连接可以对应一个进程。 Nginx Apache nginx是一个基于事件的web服务器 apache是一个基于流程的服务器 所有请求都由一个线程处理 单个线程处理单个请求 nginx避免子进程的概念 apache是基于子进程的 nginx类似于速度 apache类似于功率 nginx在内存消耗和连接方面比较好 apache在内存消耗和连接上没有提高 nginx在负载均衡方面表现较好 当流量到达进程极限时，apache将拒绝新的连接。 对于php来说，nginx可能更可取，因为它支持php apache支持php，python，per和其他语言使用插件，当应用程序基于python或ruby时，它非常有用。 nginx不支持IBMI和openvms一样的os apache支持更多的os nginx只具有核心功能 apache提供了比nginx更多的功能 nginx的性能和可伸缩性不依赖于硬件 apache依赖于cpu和内存等硬件组件。 什么是动态资源、静态资源分离？动态资源、静态资源分离，是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。动态资源、静态资源分离简单的概括是：动态文件与静态文件的分离。 为什么要做动、静分离？在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do 等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js 等等文件），这些不需要经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗？当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决动、静分离将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问这里我们将静态资源放到 Nginx 中，动态资源转发到 Tomcat 服务器中去。当然，因为现在七牛、阿里云等 CDN 服务已经很成熟，主流的做法，是把静态资源缓存到 CDN 服务中，从而提升访问速度。相比本地的 Nginx 来说，CDN 服务器由于在国内有更多的节点，可以实现用户的就近访问。并且，CDN 服务可以提供更大的带宽，不像我们自己的应用服务，提供的带宽是有限的。 什么叫 CDN 服务？CDN ，即内容分发网络。其目的是，通过在现有的 Internet中 增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可就近取得所需的内容，提高用户访问网站的速度。一般来说，因为现在 CDN 服务比较大众，所以基本所有公司都会使用 CDN 服务。 Nginx 怎么做的动静分离？只需要指定路径对应的目录。location&#x2F;可以使用正则表达式匹配。并指定对应的硬盘中的目录。如下：（操作都是在Linux上） 12345678910111213141516location /image/ &#123; root /usr/local/static/; autoindex on;&#125;步骤：# 创建目录mkdir /usr/local/static/image # 进入目录cd /usr/local/static/image # 上传照片photo.jpg # 重启nginxsudo nginx -s reload 打开浏览器 输入 server_name&#x2F;image&#x2F;1.jpg 就可以访问该静态图片了 Nginx 负载均衡的算法怎么实现的?策略有哪些?为了避免服务器崩溃，大家会通过负载均衡的方式来分担服务器压力。将对台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器。Nginx负载均衡实现的策略有以下五种： 轮询(默认) 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。 1234upstream backserver &#123;server 192.168.0.12;server 192.168.0.13;&#125; 权重 weight weight的值越大，分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。 12345# 权重越高，在被访问的概率越大，如上例，分别是20%，80%。upstream backserver &#123; server 192.168.0.12 weight=2; server 192.168.0.13 weight=8;&#125; ip_hash( IP绑定) 每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题 12345upstream backserver &#123; ip_hash; server 192.168.0.12:88; server 192.168.0.13:80;&#125; fair(第三方插件) 必须安装upstream_fair模块。对比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。 123456# 哪个服务器的响应速度快，就将请求分配到那个服务器上。upstream backserver &#123; server server1; server server2; fair;&#125; url_hash(第三方插件) 必须安装Nginx的hash软件包按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。 123456upstream backserver &#123; server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32;&#125; 如何用 Nginx 解决前端跨域问题？使用Nginx转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。 Nginx 虚拟主机怎么配置?1、基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站2、基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台3、基于ip的虚拟主机。基于虚拟主机配置域名需要建立&#x2F;data&#x2F;www &#x2F;data&#x2F;bbs目录，windows本地hosts添加虚拟机ip地址对应的域名解析；对应域名网站目录下新增index.html文件； 12345678910111213141516171819# 当客户端访问www.lijie.com,监听端口号为80,直接跳转到data/www目录下文件server &#123; listen 80; server_name www.lijie.com; location / &#123; root data/www; index index.html index.htm; &#125;&#125;# 当客户端访问www.lijie.com,监听端口号为80,直接跳转到data/bbs目录下文件 server &#123; listen 80; server_name bbs.lijie.com; location / &#123; root data/bbs; index index.html index.htm; &#125;&#125; 基于端口的虚拟主机使用端口来区分，浏览器使用域名或ip地址:端口号 访问 12345678910111213141516171819# 当客户端访问www.lijie.com,监听端口号为8080,直接跳转到data/www目录下文件 server &#123; listen 8080; server_name 8080.lijie.com; location / &#123; root data/www; index index.html index.htm; &#125;&#125;# 当客户端访问www.lijie.com,监听端口号为80直接跳转到真实ip服务器地址 127.0.0.1:8080server &#123; listen 80; server_name www.lijie.com; location / &#123; proxy_pass http://127.0.0.1:8080; index index.html index.htm; &#125;&#125; location的作用是什么？location指令的作用是根据用户请求的URI来执行不同的应用，也就是根据用户请求的网站URL进行匹配，匹配成功即进行相关的操作。location的语法能说出来吗？ 注意：~ 代表自己输入的英文字母 匹配符 匹配规则 优先级 &#x3D; 精确匹配 1 ^~ 以某个字符串开头 2 ~ 区分大小写的正则匹配 3 ~* 不区分大小写的正则匹配 4 !~ 区分大小写不匹配的正则 5 !~* 不区分大小写不匹配的正则 6 &#x2F; 通用匹配，任何请求都会匹配到 7 Location正则案例 123456789101112131415161718192021222324# 优先级1,精确匹配，根路径location =/ &#123; return 400;&#125;# 优先级2,以某个字符串开头,以av开头的，优先匹配这里，区分大小写location ^~ /av &#123; root /data/av/;&#125;# 优先级3，区分大小写的正则匹配，匹配/media*****路径location ~ /media &#123; alias /data/static/;&#125;# 优先级4 ，不区分大小写的正则匹配，所有的****.jpg|gif|png 都走这里location ~* .*\\.(jpg|gif|png|js|css)$ &#123; root /data/av/;&#125;# 优先7，通用匹配location / &#123; return 403;&#125; 限流怎么做的？Nginx限流就是限制用户请求速度，防止服务器受不了限流有3种 正常限制访问频率（正常流量） 突发限制访问频率（突发流量） 限制并发连接数 Nginx的限流都是基于漏桶流算法 实现三种限流算法 1、正常限制访问频率（正常流量）：限制一个用户发送的请求，我Nginx多久接收一个请求。Nginx中使用ngx_http_limit_req_module模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在nginx.conf配置文件中可以使用limit_req_zone命令及limit_req命令限制单个IP的请求处理频率。 123456789101112# 定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;# 绑定限流维度server&#123; location/seckill.html&#123; limit_req zone=zone; proxy_pass http://lj_seckill; &#125;&#125; 1r&#x2F;s代表1秒一个请求，1r&#x2F;m一分钟接收一个请求， 如果Nginx这时还有别人的请求没有处理完，Nginx就会拒绝处理该用户请求。2、突发限制访问频率（突发流量）：限制一个用户发送的请求，我Nginx多久接收一个。上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？Nginx提供burst参数结合nodelay参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加burst参数以及nodelay参数： 123456789101112# 定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;# 绑定限流维度server&#123; location/seckill.html&#123; limit_req zone=zone burst=5 nodelay; proxy_pass http://lj_seckill; &#125;&#125; 为什么就多了一个 burst&#x3D;5 nodelay; 呢，多了这个可以代表Nginx对于一个用户的请求会立即处理前五个，多余的就慢慢来落，没有其他用户的请求我就处理你的，有其他的请求的话我Nginx就漏掉不接受你的请求3、 限制并发连接数Nginx中的ngx_http_limit_conn_module模块提供了限制并发连接数的功能，可以使用limit_conn_zone指令以及limit_conn执行进行配置。接下来我们可以通过一个简单的例子来看下： 123456789101112http &#123; limit_conn_zone $binary_remote_addr zone=myip:10m; limit_conn_zone $server_name zone=myServerName:10m;&#125;server &#123; location / &#123; limit_conn myip 10; limit_conn myServerName 100; rewrite / http://www.lijie.net permanent; &#125;&#125; 上面配置了单个IP同时并发连接数最多只能10个连接，并且设置了整个虚拟服务器同时最大并发数最多只能100个链接。当然，只有当请求的header被服务器处理后，虚拟服务器的连接数才会计数。刚才有提到过Nginx是基于漏桶算法原理实现的，实际上限流一般都是基于漏桶算法和令牌桶算法实现的。 漏桶流算法和令牌桶算法知道？漏桶算法漏桶算法思路很简单，我们把水比作是请求，漏桶比作是系统处理能力极限，水先进入到漏桶里，漏桶里的水按一定速率流出，当流出的速率小于流入的速率时，由于漏桶容量有限，后续进入的水直接溢出（拒绝请求），以此实现限流。 令牌桶算法令牌桶算法的原理也比较简单，我们可以理解成医院的挂号看病，只有拿到号以后才可以进行诊病。系统会维护一个令牌（token）桶，以一个恒定的速度往桶里放入令牌（token），这时如果有请求进来想要被处理，则需要先从桶里获取一个令牌（token），当桶里没有令牌（token）可取时，则该请求将被拒绝服务。令牌桶算法通过控制桶的容量、发放令牌的速率，来达到对请求的限制。 Nginx配置高可用性怎么配置？当上游服务器(真实访问服务器)，一旦出现故障或者是没有及时相应的话，应该直接轮训到下一台服务器，保证服务器的高可用Nginx配置代码： 123456789101112131415server &#123; listen 80; server_name www.lijie.com; location / &#123; ### 指定上游服务器负载均衡服务器 proxy_pass http://backServer; ###nginx与上游服务器(真实访问的服务器)超时时间 后端服务器连接的超时时间_发起握手等候响应超时时间 proxy_connect_timeout 1s; ###nginx发送给上游服务器(真实访问的服务器)超时时间 proxy_send_timeout 1s; ### nginx接受上游服务器(真实访问的服务器)超时时间 proxy_read_timeout 1s; index index.html index.htm; &#125; &#125; Nginx怎么判断别IP不可访问？1234# 如果访问的ip地址为192.168.9.115,则返回403if ($remote_addr = 192.168.9.115) &#123; return 403;&#125; 在nginx中，如何使用未定义的服务器名称来阻止处理请求？只需将请求删除的服务器就可以定义为：服务器名被保留一个空字符串，他在没有主机头字段的情况下匹配请求，而一个特殊的nginx的非标准代码被返回，从而终止连接。 怎么限制浏览器访问？1234## 不允许谷歌浏览器访问 如果是谷歌浏览器返回500if ($http_user_agent ~ Chrome) &#123; return 500;&#125; Rewrite全局变量是什么？12345678910111213141516171819202122232425262728293031323334$remote_addr //获取客户端ip$binary_remote_addr //客户端ip（二进制)$remote_port //客户端port，如：50472$remote_user //已经经过Auth Basic Module验证的用户名$host //请求主机头字段，否则为服务器名称，如:blog.sakmon.com$request //用户请求信息，如：GET ?a=1&amp;b=2 HTTP/1.1$request_filename //当前请求的文件的路径名，由root或alias和URI request组合而成，如：/2013/81.html$status //请求的响应状态码,如:200$body_bytes_sent // 响应时送出的body字节数数量。即使连接中断，这个数据也是精确的,如：40$content_length // 等于请求行的“Content_Length”的值$content_type // 等于请求行的“Content_Type”的值$http_referer // 引用地址$http_user_agent // 客户端agent信息,如：Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.76 Safari/537.36$args //与$query_string相同 等于当中URL的参数(GET)，如a=1&amp;b=2$document_uri //与$uri相同 这个变量指当前的请求URI，不包括任何参数(见$args) 如:/2013/81.html$document_root //针对当前请求的根路径设置值$hostname //如：centos53.localdomain$http_cookie //客户端cookie信息$cookie_COOKIE //cookie COOKIE变量的值$is_args //如果有$args参数，这个变量等于”?”，否则等于”&quot;，空值，如?$limit_rate //这个变量可以限制连接速率，0表示不限速$query_string // 与$args相同 等于当中URL的参数(GET)，如a=1&amp;b=2$request_body // 记录POST过来的数据信息$request_body_file //客户端请求主体信息的临时文件名$request_method //客户端请求的动作，通常为GET或POST,如：GET$request_uri //包含请求参数的原始URI，不包含主机名，如：/2013/81.html?a=1&amp;b=2$scheme //HTTP方法（如http，https）,如：http$uri //这个变量指当前的请求URI，不包括任何参数(见$args) 如:/2013/81.html$request_completion //如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)，如：OK$server_protocol //请求使用的协议，通常是HTTP/1.0或HTTP/1.1，如：HTTP/1.1$server_addr //服务器IP地址，在完成一次系统调用后可以确定这个值$server_name //服务器名称，如：blog.sakmon.com$server_port //请求到达服务器的端口号,如：80 Nginx 如何实现后端服务的健康检查？方式一，利用 nginx 自带模块 ngx_http_proxy_module 和 ngx_http_upstream_module 对后端节点做健康检查。方式二(推荐)，利用 nginx_upstream_check_module 模块对后端节点做健康检查。 Nginx 如何开启压缩？开启nginx gzip压缩后，网页、css、js等静态资源的大小会大大的减少，从而可以节约大量的带宽，提高传输效率，给用户快的体验。虽然会消耗cpu资源，但是为了给用户更好的体验是值得的。开启的配置如下：将以上配置放到nginx.conf的http{ … }节点中。 1234567891011121314151617http &#123; # 开启gzip gzip on; # 启用gzip压缩的最小文件；小于设置值的文件将不会被压缩 gzip_min_length 1k; # gzip 压缩级别 1-10 gzip_comp_level 2; # 进行压缩的文件类型。 gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; # 是否在http header中添加Vary: Accept-Encoding，建议开启 gzip_vary on;&#125; 保存并重启nginx，刷新页面（为了避免缓存，请强制刷新）就能看到效果了。以谷歌浏览器为例，通过F12看请求的响应头部：我们可以先来对比下，如果我们没有开启zip压缩之前，我们的对应的文件大小，如下所示：现在我们开启了gzip进行压缩后的文件的大小，可以看到如下所示：并且我们查看响应头会看到gzip这样的压缩，如下所示gzip压缩前后效果对比：jquery原大小90kb，压缩后只有30kb。gzip虽然好用，但是以下类型的资源不建议启用。1、图片类型原因：图片如jpg、png本身就会有压缩，所以就算开启gzip后，压缩前和压缩后大小没有多大区别，所以开启了反而会白白的浪费资源。（Tips：可以试试将一张jpg图片压缩为zip，观察大小并没有多大的变化。虽然zip和gzip算法不一样，但是可以看出压缩图片的价值并不大)2、大文件原因：会消耗大量的cpu资源，且不一定有明显的效果。 ngx_http_upstream_module的作用是什么?ngx_http_upstream_module用于定义可通过fastcgi传递、proxy传递、uwsgi传递、memcached传递和scgi传递指令来引用的服务器组。 什么是C10K问题?C10K问题是指无法同时处理大量客户端(10,000)的网络套接字。 Nginx是否支持将请求压缩到上游?您可以使用Nginx模块gunzip将请求压缩到上游。gunzip模块是一个过滤器，它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编码:gzip”来解压缩响应。 如何在Nginx中获得当前的时间?要获得Nginx的当前时间，必须使用SSI模块、和date_local的变量。Proxy_set_header THE-TIME $date_gmt; 用Nginx服务器解释-s的目的是什么?用于运行Nginx -s参数的可执行文件。 如何在Nginx服务器上添加模块?在编译过程中，必须选择Nginx模块，因为Nginx不支持模块的运行时间选择。 生产中如何设置worker进程的数量呢？在有多个cpu的情况下，可以设置多个worker，worker进程的数量可以设置到和cpu的核心数一样多，如果在单个cpu上起多个worker进程，那么操作系统会在多个worker之间进行调度，这种情况会降低系统性能，如果只有一个cpu，那么只启动一个worker进程就可以了。 nginx状态码499：服务端处理时间过长，客户端主动关闭了连接。502：(1). FastCGI进程是否已经启动(2). FastCGI worker进程数是否不够(3). FastCGI执行时间过长 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300;(4).FastCGI Buffer不够，nginx和apache一样，有前端缓冲限制，可以调整缓冲参数 fastcgi_buffer_size 32k; fastcgi_buffers 8 32k;(5). Proxy Buffer不够，如果你用了Proxying，调整 proxy_buffer_size 16k; proxy_buffers 4 16k;(6).php脚本执行时间过长 将php-fpm.conf的0s的0s改成一个时间","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.cicoding.com/tags/Nginx/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"面试宝典说明","slug":"interview","date":"2023-06-22T14:28:03.000Z","updated":"2024-02-24T08:13:07.104Z","comments":false,"path":"other/interview/","link":"","permalink":"https://www.cicoding.com/other/interview/","excerpt":"","text":"本站来源于互联网收集！ 努力更新中！。。。。。","categories":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}],"tags":[{"name":"interview","slug":"interview","permalink":"https://www.cicoding.com/tags/interview/"}],"keywords":[{"name":"面试宝典","slug":"面试宝典","permalink":"https://www.cicoding.com/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"Java在线网校学习平台源码分享","slug":"code3","date":"2023-06-21T15:42:16.000Z","updated":"2023-06-22T14:15:09.335Z","comments":true,"path":"code/code3/","link":"","permalink":"https://www.cicoding.com/code/code3/","excerpt":"","text":"项目描述Java在线网校学习平台源码分享 运行环境jdk8+tomcat8+mysql5.7+eclipse（IntelliJ IDEA）+maven3.X 项目技术spring+spring mvc+mybatis+shrio+jquery+html+bootstrap 研发背景最近几年内，校园学生的数量不断而且持续增长，社会中对人才本质的要求不断增高，也更加得趋向全面化，不只专业常识要过硬，其他方面也有必定的要求，校园的专业课时刻现已很紧，学生和教师的时刻也越来越紧，传统讲堂之上的时刻是固定，学生在讲堂上和教师有沟通的时机有限，学生要在讲堂之余温习教师在讲堂上的内容，还得有时刻去学习其他方面的常识，弥补自己的常识量，确保自己的全面发展，在线学习体系的开发完结了从传统的人工教育方法转换为智能化教育，首要，计算机作为在线学习体系的东西，其自身就有为运用者供给了许多的材料的途径，可以大大的削减运用者搜索、查找材料的时刻。在线学习体系运用计算机不只以多媒体的方法体现常识和经历，还有文本笔记，材料操练，多种方法显现，可以增高用户的学习乐趣。其次，在线学习体系为传统人工教育开辟了新的新的途径，可以减轻教师的担负，相同的内容不用像曾经那样重复授课，它最大的长处在于可以便利的将教师讲课内容进行录制并上传，使学生在任何时刻都可以学习，教师可以经过自测成果对学生包容常识的状况做出剖析，减轻了教师的部分作业。最终，它可以让一切的学生都可以享用相同的资源，而且不在遭到传统讲堂上的各种束缚，可以在课余的时刻经过计算机就可以学习教师在讲堂上教育的内容，不断重复的学习，和教师沟通自已的困惑既节约了精力又节约了时刻，缓解了学生在讲堂上的压力也添加了学生讲堂学习的动力，它的完结不只可以使学生高效运用课余时刻，也增长了学生在讲堂上的有用时刻。也可以经过在线学习体系学习非本专业的常识，以便更好的进步。 数据库设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778DROP TABLE IF EXISTS `t_auth_user`;CREATE TABLE `t_auth_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `realname` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;登录用户名&#x27;, `username` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;真实姓名&#x27;, `password` varchar(32) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;, `gender` tinyint(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;性别&#x27;, `header` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;头像&#x27;, `mobile` varchar(15) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;手机号码&#x27;, `status` tinyint(1) NOT NULL DEFAULT &#x27;2&#x27; COMMENT &#x27;状态：待审核（0），有效（1），无效（3）&#x27;, `birthday` date NOT NULL DEFAULT &#x27;1900-01-01&#x27;, `education` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;学历：大专、本科、硕士、博士、博士后&#x27;, `college_code` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;大学编码&#x27;, `college_name` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;大学名称&#x27;, `cert_no` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;资格证书编号&#x27;, `title` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;头衔&#x27;, `sign` varchar(500) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;签名&#x27;, `open_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;微信公众号openid&#x27;, `wechat_id` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;微信号&#x27;, `qq` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;qq号&#x27;, `login_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27; COMMENT &#x27;最后一次登录时间&#x27;, `ip` varchar(15) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;最后一次登录IP&#x27;, `province` varchar(16) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;所在省份&#x27;, `city` varchar(16) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;所在城市&#x27;, `district` varchar(16) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;所在地区&#x27;, `weight` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;权重&#x27;, `create_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27;, `create_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `update_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `del` tinyint(1) NOT NULL DEFAULT &#x27;0&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `T_AUTH_USER_USERNAME_UNIQUE` (`username`)) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8 COMMENT=&#x27;用户表&#x27;;DROP TABLE IF EXISTS `t_consts_classify`;CREATE TABLE `t_consts_classify` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;名称&#x27;, `code` varchar(50) NOT NULL DEFAULT &#x27;&#x27;, `parent_code` varchar(50) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;父级别code&#x27;, `sort` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;排序&#x27;, `create_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27;, `create_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `update_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `del` tinyint(1) NOT NULL DEFAULT &#x27;0&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COMMENT=&#x27;课程类别表&#x27;;DROP TABLE IF EXISTS `t_consts_college`;CREATE TABLE `t_consts_college` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;名称&#x27;, `code` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;编码&#x27;, `picture` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;图片&#x27;, `create_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27;, `create_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `update_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `del` tinyint(1) NOT NULL DEFAULT &#x27;0&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8 COMMENT=&#x27;高校表结构&#x27;;DROP TABLE IF EXISTS `t_consts_dictionary`;CREATE TABLE `t_consts_dictionary` ( `id` int(11) NOT NULL AUTO_INCREMENT, `group_code` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;分组code&#x27;, `group_name` varchar(32) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;分组名称&#x27;, `key` varchar(32) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;键&#x27;, `value` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;值&#x27;, `sort` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;排序&#x27;, `create_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27;, `create_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `update_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `del` tinyint(1) NOT NULL DEFAULT &#x27;0&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;数据字典：可用于可选项值的配置等&#x27;; 系统技术架构主要技术：Spring、SpringMVC、MybatisJSP、JSTL、jQuery、HTML、CSS、JSMysqlbootstrap开发工具和环境：EclipseMavenTomcat 7JDK 1.8Mysql 5.6+Win10 操作系统 截图展示 需要请加QQ：82374126 或 QQ：746157197","categories":[{"name":"源码分享","slug":"源码分享","permalink":"https://www.cicoding.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"系统","slug":"系统","permalink":"https://www.cicoding.com/tags/%E7%B3%BB%E7%BB%9F/"}],"keywords":[{"name":"源码分享","slug":"源码分享","permalink":"https://www.cicoding.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB/"}]},{"title":"SpringBoot兼职管理系统源码","slug":"code2","date":"2023-06-19T07:41:45.000Z","updated":"2023-06-22T14:18:56.357Z","comments":true,"path":"code/code2/","link":"","permalink":"https://www.cicoding.com/code/code2/","excerpt":"","text":"项目描述当今社会的生活水平的提高，现在生活水平技术的日益增长，科学技术的不断提高，计算机科学日渐成熟，其强大的功能已为人们深刻认识，它已进入人类社会的各个领域并发挥着越来越重要的作用。越来越多的企业也必然要借助先进的信息技术来展示自己公司的信息，产品的介绍，并借助计算机技术来提高管理效率，因此网站建设所体现的重要性越来越突出。一个企业门户网站建设、运行的好坏，直接关系到一个企业的形象，也影响着其管理、服务的质量和水平。对企业门户网站的测评能直接对其建设、运行状况做出科学的评价，并据此对其未来的发展做出科学的规划。通过对企业门户网站的不断完善来推动企业内部管理体制的改革和业务流程的再造，并从根本上在企业的各个部门贯彻服务的理念。 运行环境jdk8+tomcat8+mysql5.7+IntelliJ IDEA 2020+maven3.X 项目技术(必填)spring+spring mvc+mybatis+shrio+jquery+html+bootstrap 研发背景当今时代信息技术飞速发展，人们已经处于数字化的生存空间之中。Internet构造了无限的信息资源，让我们感受到了科技带来的快感，它的普遍使用已经从根本上改变了人们的生活方式和工作方式。网络技术的迅猛发展使得基于Web的各类信息系统成为目前信息系统中最为流行的展现形式之一。基于Web的信息系统具有如下一些特点：(1)有利于信息的及时更新和发布；(2)便于操作和管理；(3)拥有良好的用户界面；(4)灵活性和可扩展性；(5)系统功能的通用性； 数据库设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293DROP TABLE IF EXISTS `t_auth_user`;CREATE TABLE `t_auth_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `realname` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;登录用户名&#x27;, `username` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;真实姓名&#x27;, `password` varchar(32) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;, `gender` tinyint(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;性别&#x27;, `header` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;头像&#x27;, `mobile` varchar(15) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;手机号码&#x27;, `status` tinyint(1) NOT NULL DEFAULT &#x27;2&#x27; COMMENT &#x27;状态：待审核（0），有效（1），无效（3）&#x27;, `birthday` date NOT NULL DEFAULT &#x27;1900-01-01&#x27;, `education` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;学历：大专、本科、硕士、博士、博士后&#x27;, `college_code` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;大学编码&#x27;, `college_name` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;大学名称&#x27;, `cert_no` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;资格证书编号&#x27;, `title` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;头衔&#x27;, `sign` varchar(500) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;签名&#x27;, `open_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;微信公众号openid&#x27;, `wechat_id` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;微信号&#x27;, `qq` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;qq号&#x27;, `login_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27; COMMENT &#x27;最后一次登录时间&#x27;, `ip` varchar(15) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;最后一次登录IP&#x27;, `province` varchar(16) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;所在省份&#x27;, `city` varchar(16) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;所在城市&#x27;, `district` varchar(16) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;所在地区&#x27;, `weight` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;权重&#x27;, `create_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27;, `create_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `update_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `del` tinyint(1) NOT NULL DEFAULT &#x27;0&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `T_AUTH_USER_USERNAME_UNIQUE` (`username`)) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8 COMMENT=&#x27;用户表&#x27;;DROP TABLE IF EXISTS `t_consts_classify`;CREATE TABLE `t_consts_classify` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;名称&#x27;, `code` varchar(50) NOT NULL DEFAULT &#x27;&#x27;, `parent_code` varchar(50) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;父级别code&#x27;, `sort` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;排序&#x27;, `create_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27;, `create_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `update_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `del` tinyint(1) NOT NULL DEFAULT &#x27;0&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COMMENT=&#x27;课程类别表&#x27;;DROP TABLE IF EXISTS `t_consts_college`;CREATE TABLE `t_consts_college` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;名称&#x27;, `code` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;编码&#x27;, `picture` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;图片&#x27;, `create_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27;, `create_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `update_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `del` tinyint(1) NOT NULL DEFAULT &#x27;0&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8 COMMENT=&#x27;高校表结构&#x27;;DROP TABLE IF EXISTS `sys_log`;CREATE TABLE `sys_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `user_id` bigint(20) DEFAULT NULL COMMENT &#x27;用户id&#x27;, `username` varchar(50) DEFAULT NULL COMMENT &#x27;用户名&#x27;, `operation` varchar(50) DEFAULT NULL COMMENT &#x27;用户操作&#x27;, `time` int(11) DEFAULT NULL COMMENT &#x27;响应时间&#x27;, `method` varchar(200) DEFAULT NULL COMMENT &#x27;请求方法&#x27;, `params` varchar(5000) DEFAULT NULL COMMENT &#x27;请求参数&#x27;, `ip` varchar(64) DEFAULT NULL COMMENT &#x27;IP地址&#x27;, `gmt_create` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=694 DEFAULT CHARSET=utf8 COMMENT=&#x27;系统日志&#x27;;DROP TABLE IF EXISTS `sys_menu`;CREATE TABLE `sys_menu` ( `menu_id` bigint(20) NOT NULL AUTO_INCREMENT, `parent_id` bigint(20) DEFAULT NULL COMMENT &#x27;父菜单ID，一级菜单为0&#x27;, `name` varchar(50) DEFAULT NULL COMMENT &#x27;菜单名称&#x27;, `url` varchar(200) DEFAULT NULL COMMENT &#x27;菜单URL&#x27;, `perms` varchar(500) DEFAULT NULL COMMENT &#x27;授权(多个用逗号分隔，如：user:list,user:create)&#x27;, `type` int(11) DEFAULT NULL COMMENT &#x27;类型 0：目录 1：菜单 2：按钮&#x27;, `icon` varchar(50) DEFAULT NULL COMMENT &#x27;菜单图标&#x27;, `order_num` int(11) DEFAULT NULL COMMENT &#x27;排序&#x27;, `gmt_create` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime DEFAULT NULL COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`menu_id`)) ENGINE=InnoDB AUTO_INCREMENT=108 DEFAULT CHARSET=utf8 COMMENT=&#x27;菜单管理&#x27;; 系统技术架构主要技术：SpringBoot、SpringMVC、Mybatisthymeleaf、jQuery、HTML、CSS、JSMysqlbootstrap开发工具和环境：EclipseMavenTomcat 8.5JDK 1.8Mysql 5.6+Win10 操作系统 截图展示 需要请加QQ：82374126 或 QQ：746157197","categories":[{"name":"源码分享","slug":"源码分享","permalink":"https://www.cicoding.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"系统","slug":"系统","permalink":"https://www.cicoding.com/tags/%E7%B3%BB%E7%BB%9F/"}],"keywords":[{"name":"源码分享","slug":"源码分享","permalink":"https://www.cicoding.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB/"}]},{"title":"Java学生成绩源码分享","slug":"code1","date":"2023-06-19T07:41:40.000Z","updated":"2023-06-21T15:32:59.233Z","comments":true,"path":"code/code1/","link":"","permalink":"https://www.cicoding.com/code/code1/","excerpt":"","text":"项目描述学生成绩管理系统是针对实际情况而进行设计、开发的，而教师管理模块充分的保证了教师信息的就是更新和展示。利用SpringBoot技术和ssm框架以及MySql数据库访问技术实现了基于Web的系统。该框架可以减少模块之间的耦合性，让开发人员减轻重新建立解决复杂问题方案的负担，并且可以被扩展以进行内部的定制化。通过使用thymeleaf模板引擎技术建设动态网站，充分发挥了Java语言所独有的易用性、跨平台性和安全性，从而构建了一个运行高效、安全可靠、适用性广的管理系统，实现了信息网上管理，满足了业务处理的需要，使学校的信息管理，成绩管理录入更便捷。论文首先简要介绍了管理系统的一些研究与应用背景，其次介绍了该网站系统所采用的开发工具、平台以及开发环境。在此基础上，论文详尽描述了管理系统情况。 运行环境jdk8+tomcat8+mysql5.7+IntelliJ IDEA 2020+maven3.X 项目技术(必填)spring+spring mvc+mybatis+shrio+jquery+html+bootstrap 研发背景当今社会的生活水平的提高，现在生活水平技术的日益增长，科学技术的不断提高，计算机科学日渐成熟，其强大的功能已为人们深刻认识，它已进入人类社会的各个领域并发挥着越来越重要的作用。越来越多的企业也必然要借助先进的信息技术来展示自己公司的信息，产品的介绍，并借助计算机技术来提高管理效率，因此网站建设所体现的重要性越来越突出。一个企业门户网站建设、运行的好坏，直接关系到一个企业的形象，也影响着其管理、服务的质量和水平。对企业门户网站的测评能直接对其建设、运行状况做出科学的评价，并据此对其未来的发展做出科学的规划。通过对企业门户网站的不断完善来推动企业内部管理体制的改革和业务流程的再造，并从根本上在企业的各个部门贯彻服务的理念。 数据库设计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394DROP TABLE IF EXISTS `t_auth_user`;CREATE TABLE `t_auth_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `realname` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;登录用户名&#x27;, `username` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;真实姓名&#x27;, `password` varchar(32) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;密码&#x27;, `gender` tinyint(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;性别&#x27;, `header` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;头像&#x27;, `mobile` varchar(15) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;手机号码&#x27;, `status` tinyint(1) NOT NULL DEFAULT &#x27;2&#x27; COMMENT &#x27;状态：待审核（0），有效（1），无效（3）&#x27;, `birthday` date NOT NULL DEFAULT &#x27;1900-01-01&#x27;, `education` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;学历：大专、本科、硕士、博士、博士后&#x27;, `college_code` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;大学编码&#x27;, `college_name` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;大学名称&#x27;, `cert_no` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;资格证书编号&#x27;, `title` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;头衔&#x27;, `sign` varchar(500) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;签名&#x27;, `open_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;微信公众号openid&#x27;, `wechat_id` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;微信号&#x27;, `qq` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;qq号&#x27;, `login_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27; COMMENT &#x27;最后一次登录时间&#x27;, `ip` varchar(15) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;最后一次登录IP&#x27;, `province` varchar(16) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;所在省份&#x27;, `city` varchar(16) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;所在城市&#x27;, `district` varchar(16) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;所在地区&#x27;, `weight` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;权重&#x27;, `create_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27;, `create_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `update_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `del` tinyint(1) NOT NULL DEFAULT &#x27;0&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `T_AUTH_USER_USERNAME_UNIQUE` (`username`)) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8 COMMENT=&#x27;用户表&#x27;;DROP TABLE IF EXISTS `t_consts_classify`;CREATE TABLE `t_consts_classify` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;名称&#x27;, `code` varchar(50) NOT NULL DEFAULT &#x27;&#x27;, `parent_code` varchar(50) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;父级别code&#x27;, `sort` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;排序&#x27;, `create_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27;, `create_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `update_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `del` tinyint(1) NOT NULL DEFAULT &#x27;0&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COMMENT=&#x27;课程类别表&#x27;;DROP TABLE IF EXISTS `t_consts_college`;CREATE TABLE `t_consts_college` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;名称&#x27;, `code` varchar(50) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;编码&#x27;, `picture` varchar(100) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;图片&#x27;, `create_time` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27;, `create_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `update_user` varchar(32) NOT NULL DEFAULT &#x27;system&#x27;, `del` tinyint(1) NOT NULL DEFAULT &#x27;0&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8 COMMENT=&#x27;高校表结构&#x27;;DROP TABLE IF EXISTS `sys_log`;CREATE TABLE `sys_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `user_id` bigint(20) DEFAULT NULL COMMENT &#x27;用户id&#x27;, `username` varchar(50) DEFAULT NULL COMMENT &#x27;用户名&#x27;, `operation` varchar(50) DEFAULT NULL COMMENT &#x27;用户操作&#x27;, `time` int(11) DEFAULT NULL COMMENT &#x27;响应时间&#x27;, `method` varchar(200) DEFAULT NULL COMMENT &#x27;请求方法&#x27;, `params` varchar(5000) DEFAULT NULL COMMENT &#x27;请求参数&#x27;, `ip` varchar(64) DEFAULT NULL COMMENT &#x27;IP地址&#x27;, `gmt_create` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=694 DEFAULT CHARSET=utf8 COMMENT=&#x27;系统日志&#x27;;DROP TABLE IF EXISTS `sys_menu`;CREATE TABLE `sys_menu` ( `menu_id` bigint(20) NOT NULL AUTO_INCREMENT, `parent_id` bigint(20) DEFAULT NULL COMMENT &#x27;父菜单ID，一级菜单为0&#x27;, `name` varchar(50) DEFAULT NULL COMMENT &#x27;菜单名称&#x27;, `url` varchar(200) DEFAULT NULL COMMENT &#x27;菜单URL&#x27;, `perms` varchar(500) DEFAULT NULL COMMENT &#x27;授权(多个用逗号分隔，如：user:list,user:create)&#x27;, `type` int(11) DEFAULT NULL COMMENT &#x27;类型 0：目录 1：菜单 2：按钮&#x27;, `icon` varchar(50) DEFAULT NULL COMMENT &#x27;菜单图标&#x27;, `order_num` int(11) DEFAULT NULL COMMENT &#x27;排序&#x27;, `gmt_create` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime DEFAULT NULL COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`menu_id`)) ENGINE=InnoDB AUTO_INCREMENT=108 DEFAULT CHARSET=utf8 COMMENT=&#x27;菜单管理&#x27;; 系统技术架构主要技术：SpringBoot、SpringMVC、Mybatisthymeleaf、jQuery、HTML、CSS、JSMysqlbootstrap开发工具和环境：EclipseMavenTomcat 8.5JDK 1.8Mysql 5.6+Win10 操作系统 需要请加QQ：82374126 或 QQ：746157197","categories":[{"name":"源码分享","slug":"源码分享","permalink":"https://www.cicoding.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"系统","slug":"系统","permalink":"https://www.cicoding.com/tags/%E7%B3%BB%E7%BB%9F/"}],"keywords":[{"name":"源码分享","slug":"源码分享","permalink":"https://www.cicoding.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB/"}]}]}