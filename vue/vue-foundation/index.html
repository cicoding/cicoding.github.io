<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="编程分享网站">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.3.0">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.cicoding.com">
    <meta name="baidu-site-verification" content="codeva-UPbQP9x8sR" />
    <!--SEO-->

<meta name="keywords" content="VUE" />


<meta name="description" content="1. Vue的基本原理当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter&#x2F;se..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    VUE基础面试题 |
    
    编程分享网站
</title>

<link rel="alternate" href="/atom.xml" title="编程分享网站" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<script>
(function() {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<meta name="generator" content="Hexo 6.3.0"></head>

<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='zhaokejin'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>

    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://www.cicoding.com">
                        编程分享网站</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/源码分享/"><i class="fa "></i>
                                源码分享</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/面试宝典/"><i class="fa "></i>
                                面试宝典</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/tags/VUE/"><i class="fa "></i>
                                前端面试</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="VUE基础面试题">
            
            VUE基础面试题
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">面试宝典</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-none-link" href="/tags/VUE/" rel="tag">VUE</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2024/02/02</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h3 id="1-Vue的基本原理"><a href="#1-Vue的基本原理" class="headerlink" title="1. Vue的基本原理"></a>1. Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter&#x2F;setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p>
<h3 id="2-双向数据绑定的原理"><a href="#2-双向数据绑定的原理" class="headerlink" title="2. 双向数据绑定的原理"></a>2. 双向数据绑定的原理</h3><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p>
<ol>
<li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>
<li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>
<li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>
<li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>
</ol>
<h3 id="3-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#3-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p>
<p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p>
<h3 id="4-MVVM、MVC、MVP的区别"><a href="#4-MVVM、MVC、MVP的区别" class="headerlink" title="4. MVVM、MVC、MVP的区别"></a>4. MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p>
<p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p>
<p>（1）MVC</p>
<p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p>
<p>（2）MVVM</p>
<p>MVVM 分为 Model、View、ViewModel：</p>
<blockquote>
<p>Model代表数据模型，数据和业务逻辑都在Model层中定义；</p>
<p> View代表UI视图，负责数据的展示；</p>
<p>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</p>
</blockquote>
<p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p>
<p>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。</p>
<p>（3）MVP</p>
<p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p>
<h3 id="5-Computed-和-Watch-的区别"><a href="#5-Computed-和-Watch-的区别" class="headerlink" title="5. Computed 和 Watch 的区别"></a>5. Computed 和 Watch 的区别</h3><p>对于Computed：</p>
<ul>
<li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li>
<li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li>
<li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li>
<li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li>
</ul>
<p>对于Watch：</p>
<ul>
<li>它不支持缓存，数据变化时，它就会触发相应的操作</li>
<li>支持异步监听</li>
<li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li>
<li>当一个属性发生变化时，就需要执行相应的操作</li>
<li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：</li>
<li>immediate：组件加载立即触发回调函数</li>
<li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li>
</ul>
<p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p>
<p>总结：</p>
<ul>
<li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 </li>
<li>watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li>
</ul>
<p>运用场景： </p>
<ul>
<li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。 </li>
<li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h3 id="6-Computed-和-Methods-的区别"><a href="#6-Computed-和-Methods-的区别" class="headerlink" title="6. Computed 和 Methods 的区别"></a>6. Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的</p>
<p>不同点： </p>
<ul>
<li><p>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</p>
</li>
<li><p>method 调用总会执行该函数。</p>
</li>
</ul>
<h3 id="7-slot是什么？有什么作用？原理是什么？"><a href="#7-slot是什么？有什么作用？原理是什么？" class="headerlink" title="7. slot是什么？有什么作用？原理是什么？"></a>7. slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p>
<ul>
<li>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li>
<li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li>
<li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li>
</ul>
<p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p>
<h3 id="8-过滤器的作用，如何实现一个过滤器"><a href="#8-过滤器的作用，如何实现一个过滤器" class="headerlink" title="8. 过滤器的作用，如何实现一个过滤器"></a>8. 过滤器的作用，如何实现一个过滤器</h3><p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用filters来过滤数据，filters不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。</p>
<p>使用场景：</p>
<ul>
<li><p>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出显示。</p>
</li>
<li><p>比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。</p>
</li>
</ul>
<p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式<code>&#123;&#123;&#125;&#125;</code>和 v-bind 表达式 中，然后放在操作符<code>|</code>后面进行指示。</p>
<h3 id="9-如何保存页面的当前的状态"><a href="#9-如何保存页面的当前的状态" class="headerlink" title="9. 如何保存页面的当前的状态"></a>9. 如何保存页面的当前的状态</h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p>
<ul>
<li><p>前组件会被卸载</p>
</li>
<li><p>前组件不会被卸载</p>
</li>
</ul>
<p>那么可以按照这两种情况分别得到以下方法：</p>
<p>组件会被卸载：</p>
<p>（1）将状态存储在LocalStorage &#x2F; SessionStorage</p>
<p>只需要在组件即将被销毁的生命周期中在 LocalStorage &#x2F; SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p>
<p>比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p>
<p>优点</p>
<ul>
<li><p>兼容性好，不需要额外库或工具。</p>
</li>
<li><p>简单快捷，基本可以满足大部分需求。</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li><p>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</p>
</li>
<li><p>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</p>
</li>
</ul>
<p>（2）路由传值</p>
<p>通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p>
<p>在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p>
<p>优点</p>
<ul>
<li><p>简单快捷，不会污染 LocalStorage &#x2F; SessionStorage。</p>
</li>
<li><p>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify &#x2F; parse 的不足）</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li>
</ul>
<p>组件不会被卸载：</p>
<p>（1）单页面渲染</p>
<p>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p>
<p>优点</p>
<ul>
<li><p>代码量少</p>
</li>
<li><p>不需要考虑状态传递过程中的错误</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li><p>增加 A 组件维护成本</p>
</li>
<li><p>需要传入额外的 prop 到 B 组件</p>
</li>
<li><p>无法利用路由定位页面</p>
</li>
</ul>
<p>除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行</p>
<p>被包裹在keep-alive中的组件的状态将会被保留：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">         &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/kepp-alive&gt;</span><br></pre></td></tr></table></figure>

<p>router.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/&#x27;,</span><br><span class="line">  name: &#x27;xxx&#x27;,</span><br><span class="line">  component: ()=&gt;import(&#x27;../src/views/xxx.vue&#x27;),</span><br><span class="line">  meta:&#123;</span><br><span class="line">    keepAlive: true // 需要被缓存</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="10-常见的事件修饰符及其作用"><a href="#10-常见的事件修饰符及其作用" class="headerlink" title="10. 常见的事件修饰符及其作用"></a>10. 常见的事件修饰符及其作用</h3><ul>
<li><p>stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；</p>
</li>
<li><p>prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</p>
</li>
<li><p>capture ：与事件冒泡的方向相反，事件捕获由外到内；</p>
</li>
<li><p>self ：只会触发自己范围内的事件，不包含子元素；</p>
</li>
<li><p>once ：只会触发一次。</p>
</li>
</ul>
<h3 id="11-v-if、v-show、v-html-的原理"><a href="#11-v-if、v-show、v-html-的原理" class="headerlink" title="11. v-if、v-show、v-html 的原理"></a>11. v-if、v-show、v-html 的原理</h3><ul>
<li><p>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</p>
</li>
<li><p>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display； </p>
</li>
<li><p>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</p>
</li>
</ul>
<h3 id="13-v-if和v-show的区别"><a href="#13-v-if和v-show的区别" class="headerlink" title="13.v-if和v-show的区别"></a>13.v-if和v-show的区别</h3><ul>
<li><p>手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</p>
</li>
<li><p>编译过程：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</p>
</li>
<li><p>编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</p>
</li>
<li><p>性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</p>
</li>
<li><p>使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。</p>
</li>
</ul>
<h3 id="14-v-model-是如何实现的，语法糖实际是什么？"><a href="#14-v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="14.v-model 是如何实现的，语法糖实际是什么？"></a>14.v-model 是如何实现的，语法糖实际是什么？</h3><p>（1）作用在表单元素上</p>
<p>动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;sth&quot; /&gt;</span><br><span class="line">//  等同于</span><br><span class="line">&lt;input </span><br><span class="line">    v-bind:value=&quot;message&quot; </span><br><span class="line">    v-on:input=&quot;message=$event.target.value&quot;</span><br><span class="line">&gt; </span><br><span class="line">//$event 指代当前触发的事件对象;</span><br><span class="line">//$event.target 指代当前触发的事件对象的dom;</span><br><span class="line">//$event.target.value 就是当前dom的value值;</span><br><span class="line">//在@input方法中，value =&gt; sth;</span><br><span class="line">//在:value中,sth =&gt; value;</span><br></pre></td></tr></table></figure>

<p>（2）作用在组件上</p>
<p>在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p>
<p>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。因此父组件 v-model 语法糖本质上可以修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child :value=&quot;message&quot;  @input=&quot;function(e)&#123;message = e&#125;&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>

<p>在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;aa-input v-model=&quot;aa&quot;&gt;&lt;/aa-input&gt;</span><br><span class="line">// 等价于</span><br><span class="line">&lt;aa-input v-bind:value=&quot;aa&quot; v-on:input=&quot;aa=$event.target.value&quot;&gt;&lt;/aa-input&gt;</span><br><span class="line"> </span><br><span class="line">// 子组件：</span><br><span class="line">&lt;input v-bind:value=&quot;aa&quot; v-on:input=&quot;onmessage&quot;&gt;&lt;/aa-input&gt;</span><br><span class="line"> </span><br><span class="line">props:&#123;value:aa,&#125;</span><br><span class="line">methods:&#123;</span><br><span class="line">    onmessage(e)&#123;</span><br><span class="line">        $emit(&#x27;input&#x27;,e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input $emit过来的值。</p>
<h3 id="15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？"><a href="#15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？" class="headerlink" title="15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？"></a>15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</h3><p>可以。v-model 实际上是一个语法糖，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;searchText&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>实际上相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event.target.value&quot;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<p>用在自定义组件上也是同理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input v-model=&quot;searchText&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event&quot;</span><br><span class="line">&gt;&lt;/custom-input&gt;</span><br></pre></td></tr></table></figure>

<p>显然，custom-input 与父组件的交互如下：</p>
<ol>
<li>父组件将searchText变量传入custom-input 组件，使用的 prop 名为value；</li>
<li>custom-input 组件向父组件传出名为input的事件，父组件将接收到的值赋值给searchText；</li>
</ol>
<p>所以，custom-input 组件的实现应该类似于这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;custom-input&#x27;, &#123;</span><br><span class="line">  props: [&#x27;value&#x27;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      v-bind:value=&quot;value&quot;</span><br><span class="line">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="16-data为什么是一个函数而不是对象"><a href="#16-data为什么是一个函数而不是对象" class="headerlink" title="16. data为什么是一个函数而不是对象"></a>16. data为什么是一个函数而不是对象</h3><p>Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。</p>
<h3 id="17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？"><a href="#17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？" class="headerlink" title="17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？"></a>17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p>
<p>（1）keep-alive</p>
<p>keep-alive有以下三个属性：</p>
<ul>
<li><p>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</p>
</li>
<li><p>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</p>
</li>
<li><p>max 数字，最多可以缓存多少组件实例。</p>
</li>
</ul>
<p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p>
<p>主要流程</p>
<ol>
<li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li>
<li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li>
<li>key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li>
<li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li>
</ol>
<p>（2）keep-alive 的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const patternTypes: Array&lt;Function&gt; = [String, RegExp, Array] // 接收：字符串，正则，数组</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;keep-alive&#x27;,</span><br><span class="line">  abstract: true, // 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span><br><span class="line"> </span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes, // 匹配的组件，缓存</span><br><span class="line">    exclude: patternTypes, // 不去匹配的组件，不缓存</span><br><span class="line">    max: [String, Number], // 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  created() &#123;</span><br><span class="line">    // 用于初始化缓存虚拟DOM数组和vnode的key</span><br><span class="line">    this.cache = Object.create(null)</span><br><span class="line">    this.keys = []</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    // 销毁缓存cache的组件实例</span><br><span class="line">    for (const key in this.cache) &#123;</span><br><span class="line">      pruneCacheEntry(this.cache, key, this.keys)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // prune 削减精简[v.]</span><br><span class="line">    // 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容</span><br><span class="line">    this.$watch(&#x27;include&#x27;, (val) =&gt; &#123;</span><br><span class="line">      pruneCache(this, (name) =&gt; matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">    this.$watch(&#x27;exclude&#x27;, (val) =&gt; &#123;</span><br><span class="line">      pruneCache(this, (name) =&gt; !matches(val, name))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>render函数：</p>
<ol>
<li>会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li>
<li>keep-alive 只对第一个组件有效，所以获取第一个子组件。</li>
<li>和 keep-alive 搭配使用的一般有：动态组件 和router-view</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  //</span><br><span class="line">  function getFirstComponentChild (children: ?Array&lt;VNode&gt;): ?VNode &#123;</span><br><span class="line">    if (Array.isArray(children)) &#123;</span><br><span class="line">  for (let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">    const c = children[i]</span><br><span class="line">    if (isDef(c) &amp;&amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) &#123;</span><br><span class="line">      return c</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  const slot = this.$slots.default // 获取默认插槽</span><br><span class="line">  const vnode: VNode = getFirstComponentChild(slot)// 获取第一个子组件</span><br><span class="line">  const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions // 组件参数</span><br><span class="line">  if (componentOptions) &#123; // 是否有组件参数</span><br><span class="line">    // check pattern</span><br><span class="line">    const name: ?string = getComponentName(componentOptions) // 获取组件名</span><br><span class="line">    const &#123; include, exclude &#125; = this</span><br><span class="line">    if (</span><br><span class="line">      // not included</span><br><span class="line">      (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">      // excluded</span><br><span class="line">      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">    ) &#123;</span><br><span class="line">      // 如果不匹配当前组件的名字和include以及exclude</span><br><span class="line">      // 那么直接返回组件的实例</span><br><span class="line">      return vnode</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    const &#123; cache, keys &#125; = this</span><br><span class="line"> </span><br><span class="line">    // 获取这个组件的key</span><br><span class="line">    const key: ?string = vnode.key == null</span><br><span class="line">      // same constructor may get registered as different local components</span><br><span class="line">      // so cid alone is not enough (#3269)</span><br><span class="line">      ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;)</span><br><span class="line">      : vnode.key</span><br><span class="line"> </span><br><span class="line">    if (cache[key]) &#123;</span><br><span class="line">      // LRU缓存策略执行</span><br><span class="line">      vnode.componentInstance = cache[key].componentInstance // 组件初次渲染的时候componentInstance为undefined</span><br><span class="line"> </span><br><span class="line">      // make current key freshest</span><br><span class="line">      remove(keys, key)</span><br><span class="line">      keys.push(key)</span><br><span class="line">      // 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除</span><br><span class="line">      // 使用时间间隔最长的一个</span><br><span class="line">      cache[key] = vnode</span><br><span class="line">      keys.push(key)</span><br><span class="line">      // prune oldest entry</span><br><span class="line">      if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;</span><br><span class="line">        pruneCacheEntry(cache, keys[0], keys, this._vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将组件的keepAlive属性设置为true</span><br><span class="line">    vnode.data.keepAlive = true // 作用：判断是否要执行组件的created、mounted生命周期函数</span><br><span class="line">  &#125;</span><br><span class="line">  return vnode || (slot &amp;&amp; slot[0])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p>
<p>实现步骤：</p>
<ol>
<li>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li>
<li>通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li>
<li>需要缓存，判断他当前是否在缓存数组里面：</li>
</ol>
<ul>
<li><p>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</p>
</li>
<li><p>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</p>
</li>
</ul>
<ol>
<li>最后将这个组件的 keepAlive 设置为 true</li>
</ol>
<p>（3）keep-alive 本身的创建过程和 patch 过程</p>
<p>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p>
<p>首次渲染</p>
<ul>
<li>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// core/instance/lifecycle</span><br><span class="line">function initLifecycle (vm: Component) &#123;</span><br><span class="line">  const options = vm.$options</span><br><span class="line"> </span><br><span class="line">  // locate first non-abstract parent</span><br><span class="line">  let parent = options.parent</span><br><span class="line">  if (parent &amp;&amp; !options.abstract) &#123; // 判断组件的abstract属性，才往父组件里面挂载DOM</span><br><span class="line">    while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    parent.$children.push(vm)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  vm.$parent = parent</span><br><span class="line">  vm.$root = parent ? parent.$root : vm</span><br><span class="line"> </span><br><span class="line">  vm.$children = []</span><br><span class="line">  vm.$refs = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  vm._watcher = null</span><br><span class="line">  vm._inactive = null</span><br><span class="line">  vm._directInactive = false</span><br><span class="line">  vm._isMounted = false</span><br><span class="line">  vm._isDestroyed = false</span><br><span class="line">  vm._isBeingDestroyed = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// core/vdom/create-component</span><br><span class="line">init (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123;</span><br><span class="line">    if (</span><br><span class="line">      vnode.componentInstance &amp;&amp;</span><br><span class="line">      !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">      vnode.data.keepAlive</span><br><span class="line">    ) &#123; // componentInstance在初次是undefined!!!</span><br><span class="line">      // kept-alive components, treat as a patch</span><br><span class="line">      const mountedNode: any = vnode // work around flow</span><br><span class="line">      componentVNodeHooks.prepatch(mountedNode, mountedNode) // prepatch函数执行的是组件更新的过程</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const child = vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">        vnode,</span><br><span class="line">        activeInstance</span><br><span class="line">      )</span><br><span class="line">      child.$mount(hydrating ? vnode.elm : undefined, hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p>
<p>（4）LRU （least recently used）缓存策略</p>
<p>LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。</p>
<p>LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是”如果数据最近被访问过，那么将来被访问的几率也更高”。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶ </p>
<ul>
<li><p>新数据插入到链表头部</p>
</li>
<li><p>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</p>
</li>
</ul>
<p>链表满的时候，将链表尾部的数据丢弃。</p>
<h3 id="18-nextTick-原理及作用"><a href="#18-nextTick-原理及作用" class="headerlink" title="18. $nextTick 原理及作用"></a>18. $nextTick 原理及作用</h3><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p>
<p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微&#x2F;宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p>
<p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p>
<p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p>
<ul>
<li><p>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI&#x2F;DOM 的渲染，可以减少一些无用渲染</p>
</li>
<li><p>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</p>
</li>
</ul>
<p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。</p>
<p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">    // 获取数据的操作...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>所以，在以下情况下，会用到nextTick：</p>
<ul>
<li><p>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。</p>
</li>
<li><p>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。</p>
</li>
</ul>
<p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。</p>
<h3 id="19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a>19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">   &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">         &lt;li v-for=&quot;value in obj&quot; :key=&quot;value&quot;&gt; &#123;&#123;value&#125;&#125; &lt;/li&gt; </span><br><span class="line">      &lt;/ul&gt; </span><br><span class="line">      &lt;button @click=&quot;addObjB&quot;&gt;添加 obj.b&lt;/button&gt; </span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123; </span><br><span class="line">       data () &#123; </span><br><span class="line">          return &#123; </span><br><span class="line">              obj: &#123; </span><br><span class="line">                  a: &#x27;obj.a&#x27; </span><br><span class="line">              &#125; </span><br><span class="line">          &#125; </span><br><span class="line">       &#125;,</span><br><span class="line">       methods: &#123; </span><br><span class="line">          addObjB () &#123; </span><br><span class="line">              this.obj.b = &#x27;obj.b&#x27; </span><br><span class="line">              console.log(this.obj) </span><br><span class="line">          &#125; </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addObjB () (</span><br><span class="line">   this.$set(this.obj, &#x27;b&#x27;, &#x27;obj.b&#x27;)</span><br><span class="line">   console.log(this.obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p>
<h3 id="20-Vue中封装的数组方法有哪些，其如何实现页面更新"><a href="#20-Vue中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="20. Vue中封装的数组方法有哪些，其如何实现页面更新"></a>20. Vue中封装的数组方法有哪些，其如何实现页面更新</h3><p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。</p>
<p><img src="/images/vue/clip_image002.gif" alt="VUE基础面试题"></p>
<p>那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 缓存数组原型</span><br><span class="line">const arrayProto = Array.prototype;</span><br><span class="line">// 实现 arrayMethods.__proto__ === Array.prototype</span><br><span class="line">export const arrayMethods = Object.create(arrayProto);</span><br><span class="line">// 需要进行功能拓展的方法</span><br><span class="line">const methodsToPatch = [</span><br><span class="line">  &quot;push&quot;,</span><br><span class="line">  &quot;pop&quot;,</span><br><span class="line">  &quot;shift&quot;,</span><br><span class="line">  &quot;unshift&quot;,</span><br><span class="line">  &quot;splice&quot;,</span><br><span class="line">  &quot;sort&quot;,</span><br><span class="line">  &quot;reverse&quot;</span><br><span class="line">];</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> */</span><br><span class="line">methodsToPatch.forEach(function(method) &#123;</span><br><span class="line">  // 缓存原生数组方法</span><br><span class="line">  const original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, function mutator(...args) &#123;</span><br><span class="line">    // 执行并缓存原生数组功能</span><br><span class="line">    const result = original.apply(this, args);</span><br><span class="line">    // 响应式处理</span><br><span class="line">    const ob = this.__ob__;</span><br><span class="line">    let inserted;</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">    // push、unshift会新增索引，所以要手动observer</span><br><span class="line">      case &quot;push&quot;:</span><br><span class="line">      case &quot;unshift&quot;:</span><br><span class="line">        inserted = args;</span><br><span class="line">        break;</span><br><span class="line">      // splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。</span><br><span class="line">      case &quot;splice&quot;:</span><br><span class="line">        inserted = args.slice(2);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    // </span><br><span class="line">    if (inserted) ob.observeArray(inserted);// 获取插入的值，并设置响应式监听</span><br><span class="line">    // notify change</span><br><span class="line">    ob.dep.notify();// 通知依赖更新</span><br><span class="line">    // 返回原生数组方法的执行结果</span><br><span class="line">    return result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过target__proto__ &#x3D;&#x3D; arrayMethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p>
<h3 id="21-Vue-单页应用与多页应用的区别"><a href="#21-Vue-单页应用与多页应用的区别" class="headerlink" title="21. Vue 单页应用与多页应用的区别"></a>21. Vue 单页应用与多页应用的区别</h3><p>概念：</p>
<ul>
<li><p>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</p>
</li>
<li><p>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</p>
</li>
</ul>
<p>区别：</p>
<p><img src="/images/vue/vue-1.png" alt="VUE基础面试题"></p>
<h3 id="22-Vue-template-到-render-的过程"><a href="#22-Vue-template-到-render-的过程" class="headerlink" title="22. Vue template 到 render 的过程"></a>22. Vue template 到 render 的过程</h3><p>vue的模版编译过程主要如下：template -&gt; ast -&gt; render函数</p>
<p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将模板编译为render函数</span><br><span class="line">const &#123; render, staticRenderFns &#125; = compileToFunctions(template,options//省略&#125;, this)</span><br></pre></td></tr></table></figure>

<p>CompileToFunctions中的主要逻辑如下∶</p>
<p>（1）调用parse方法将template转化为ast（抽象语法树）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constast = parse(template.trim(), options)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>parse的目标：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</p>
</li>
<li><p>解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</p>
</li>
</ul>
<p>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p>
<p>（2）对静态节点做优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimize(ast,options)</span><br></pre></td></tr></table></figure>

<p>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p>
<p>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p>
<p>（3）生成代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const code = generate(ast, options)</span><br></pre></td></tr></table></figure>

<p>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 new Function( render) 生成render函数。</p>
<h3 id="23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p>
<h3 id="24-简述-mixin、extends-的覆盖逻辑"><a href="#24-简述-mixin、extends-的覆盖逻辑" class="headerlink" title="24. 简述 mixin、extends 的覆盖逻辑"></a>24. 简述 mixin、extends 的覆盖逻辑</h3><p>（1）mixin 和 extends</p>
<p>mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p>
<ul>
<li><p>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</p>
</li>
<li><p>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</p>
</li>
</ul>
<p><img src="/images/vue/vue-2.png" alt="image-20240202233217284"></p>
<p>（2）mergeOptions 的执行过程</p>
<p>·     规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</p>
<p>·     对未合并的选项，进行判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(!child._base) &#123;</span><br><span class="line">    if(child.extends) &#123;</span><br><span class="line">        parent = mergeOptions(parent, child.extends, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    if(child.mixins) &#123;</span><br><span class="line">        for(let i = 0, l = child.mixins.length; i &lt; l; i++)&#123;</span><br><span class="line">            parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</p>
</li>
<li><p>返回合并结果 options。</p>
</li>
</ul>
<h3 id="25-描述下Vue自定义指令"><a href="#25-描述下Vue自定义指令" class="headerlink" title="25. 描述下Vue自定义指令"></a>25. 描述下Vue自定义指令</h3><p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p>
<p>一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据; </p>
<p>（1）自定义指令基本内容</p>
<ul>
<li><p>全局定义：Vue.directive(“focus”,{})</p>
</li>
<li><p>局部定义：directives:{focus:{}}</p>
</li>
<li><p>钩子函数：指令定义对象提供钩子函数</p>
<ul>
<li><p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
</li>
<li><p>inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p>
</li>
<li><p>update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</p>
</li>
<li><p>ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。</p>
</li>
<li><p>unbind：只调用一次，指令与元素解绑时调用。</p>
</li>
</ul>
</li>
<li><p>钩子函数参数</p>
<ul>
<li><p>el：绑定元素</p>
</li>
<li><p>bing： 指令核心对象，描述指令全部信息属性</p>
</li>
<li><p>name</p>
</li>
<li><p>value</p>
</li>
<li><p>oldValue</p>
</li>
<li><p>expression</p>
</li>
<li><p>arg</p>
</li>
<li><p>modifers</p>
</li>
<li><p>vnode 虚拟节点</p>
</li>
<li><p>oldVnode：上一个虚拟节点（更新钩子函数中才有用）</p>
</li>
</ul>
</li>
</ul>
<p>（2）使用场景</p>
<ul>
<li><p>普通DOM元素进行底层操作的时候，可以使用自定义指令</p>
</li>
<li><p>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</p>
</li>
</ul>
<p>（3）使用案例</p>
<p>初级应用：</p>
<ul>
<li><p>鼠标聚焦</p>
</li>
<li><p>下拉菜单</p>
</li>
<li><p>相对时间转换</p>
</li>
<li><p>滚动动画</p>
</li>
</ul>
<p>高级应用：</p>
<ul>
<li><p>自定义指令实现图片懒加载</p>
</li>
<li><p>自定义指令集成第三方插件</p>
</li>
</ul>
<h3 id="26-子组件可以直接改变父组件的数据吗？"><a href="#26-子组件可以直接改变父组件的数据吗？" class="headerlink" title="26. 子组件可以直接改变父组件的数据吗？"></a>26. 子组件可以直接改变父组件的数据吗？</h3><p>​	子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>​	Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p>
<p>​	只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>
<h3 id="27-Vue是如何收集依赖的？"><a href="#27-Vue是如何收集依赖的？" class="headerlink" title="27. Vue是如何收集依赖的？"></a>27. Vue是如何收集依赖的？</h3><p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function defieneReactive (obj, key, val)&#123;</span><br><span class="line">  const dep = new Dep();</span><br><span class="line">  ...</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    ...</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line">      if(Dep.target)&#123;</span><br><span class="line">        dep.depend();</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      return val</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上只保留了关键代码，主要就是 const dep &#x3D; new Dep()实例化一个 Dep 的实例，然后在 get 函数中通过 dep.depend() 进行依赖收集。</p>
<p>（1）Dep</p>
<p>Dep是整个依赖收集的核心，其关键代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Dep &#123;</span><br><span class="line">  static target;</span><br><span class="line">  subs;</span><br><span class="line"> </span><br><span class="line">  constructor () &#123;</span><br><span class="line">    ...</span><br><span class="line">    this.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  removeSub (sub) &#123;</span><br><span class="line">    remove(this.sub, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  depend () &#123;</span><br><span class="line">    if(Dep.target)&#123;</span><br><span class="line">      Dep.target.addDep(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  notify () &#123;</span><br><span class="line">    const subs = this.subds.slice();</span><br><span class="line">    for(let i = 0;i &lt; subs.length; i++)&#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p>
<p>（2）Watcher</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  getter;</span><br><span class="line">  ...</span><br><span class="line">  constructor (vm, expression)&#123;</span><br><span class="line">    ...</span><br><span class="line">    this.getter = expression;</span><br><span class="line">    this.get();</span><br><span class="line">  &#125;</span><br><span class="line">  get () &#123;</span><br><span class="line">    pushTarget(this);</span><br><span class="line">    value = this.getter.call(vm, vm)</span><br><span class="line">    ...</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">  addDep (dep)&#123;</span><br><span class="line">        ...</span><br><span class="line">    dep.addSub(this)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">function pushTarget (_target) &#123;</span><br><span class="line">  Dep.target = _target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p>
<p>（3）过程</p>
<p>在实例化 Vue 时，依赖收集的相关过程如下∶</p>
<p>初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。</p>
<p>初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = () =&gt; &#123;</span><br><span class="line">  vm._update(vm._render())</span><br><span class="line">&#125;</span><br><span class="line">new Watcher(vm, updateComponent)</span><br></pre></td></tr></table></figure>

<p>get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p>
<p>this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p>
<h3 id="28-对-React-和-Vue-的理解，它们的异同"><a href="#28-对-React-和-Vue-的理解，它们的异同" class="headerlink" title="28. 对 React 和 Vue 的理解，它们的异同"></a>28. 对 React 和 Vue 的理解，它们的异同</h3><p>相似之处：</p>
<ul>
<li><p>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</p>
</li>
<li><p>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</p>
</li>
<li><p>都使用了Virtual DOM（虚拟DOM）提高重绘性能；</p>
</li>
<li><p>都有props的概念，允许组件间的数据传递；</p>
</li>
<li><p>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</p>
</li>
</ul>
<p>不同之处 ：</p>
<p>1）数据流</p>
<p>Vue默认支持数据双向绑定，而React一直提倡单向数据流 </p>
<p>2）虚拟DOM</p>
<p>Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。</p>
<ul>
<li><p>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</p>
</li>
<li><p>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent&#x2F;shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</p>
</li>
</ul>
<p>3）组件化</p>
<p>React与Vue最大的不同是模板的编写。</p>
<ul>
<li><p>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</p>
</li>
<li><p>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</p>
</li>
</ul>
<p>具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。</p>
<p>4）监听数据变化的实现原理不同</p>
<ul>
<li><p>Vue 通过 getter&#x2F;setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</p>
</li>
<li><p>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent&#x2F;shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</p>
</li>
</ul>
<p>5）高阶组件</p>
<p>react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p>
<p>高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p>
<p>6）构建工具</p>
<p>两者都有自己的构建工具：</p>
<ul>
<li><p>React &#x3D;&#x3D;&gt; Create React APP</p>
</li>
<li><p>Vue &#x3D;&#x3D;&gt; vue-cli</p>
</li>
</ul>
<p>7）跨平台</p>
<ul>
<li><p>React &#x3D;&#x3D;&gt; React Native</p>
</li>
<li><p>Vue &#x3D;&#x3D;&gt; Weex</p>
</li>
</ul>
<h3 id="29-Vue的优点"><a href="#29-Vue的优点" class="headerlink" title="29. Vue的优点"></a>29. Vue的优点</h3><ul>
<li><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；</p>
</li>
<li><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p>
</li>
<li><p>双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；</p>
</li>
<li><p>组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；</p>
</li>
<li><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p>
</li>
<li><p>虚拟DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；</p>
</li>
<li><p>运行速度更快：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势。</p>
</li>
</ul>
<h3 id="30-assets和static的区别"><a href="#30-assets和static的区别" class="headerlink" title="30. assets和static的区别"></a>30. assets和static的区别</h3><p>相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p>
<p>不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p>
<p>建议： 将项目中 template需要的样式文件js文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p>
<h3 id="31-delete和Vue-delete删除数组的区别"><a href="#31-delete和Vue-delete删除数组的区别" class="headerlink" title="31. delete和Vue.delete删除数组的区别"></a>31. delete和Vue.delete删除数组的区别</h3><ul>
<li><p>delete 只是被删除的元素变成了 empty&#x2F;undefined 其他的元素的键值还是不变。</p>
</li>
<li><p>Vue.delete 直接删除了数组 改变了数组的键值。</p>
</li>
</ul>
<h3 id="32-vue如何监听对象或者数组某个属性的变化"><a href="#32-vue如何监听对象或者数组某个属性的变化" class="headerlink" title="32. vue如何监听对象或者数组某个属性的变化"></a>32. vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p>
<p>解决方式：</p>
<ul>
<li>this.$set(你要改变的数组&#x2F;对象，你要改变的位置&#x2F;key，你要改成什么value)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$set(this.arr, 0, &quot;OBKoro1&quot;); // 改变数组</span><br><span class="line">this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象</span><br></pre></td></tr></table></figure>

<ul>
<li>调用以下几个数组的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">splice()、 push()、pop()、shift()、unshift()、sort()、reverse()</span><br></pre></td></tr></table></figure>

<p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除&#x2F;添加操作</p>
<p>vm.$set 的实现原理是：</p>
<ul>
<li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li>
</ul>
<p>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</p>
<h3 id="33-什么是-mixin-？"><a href="#33-什么是-mixin-？" class="headerlink" title="33. 什么是 mixin ？"></a>33. 什么是 mixin ？</h3><ul>
<li><p>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</p>
</li>
<li><p>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</p>
</li>
<li><p>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</p>
</li>
</ul>
<h3 id="34-Vue模版编译原理"><a href="#34-Vue模版编译原理" class="headerlink" title="34. Vue模版编译原理"></a>34. Vue模版编译原理</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p>
<ul>
<li><p>解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</p>
</li>
<li><p>优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</p>
</li>
<li><p>生成阶段：将最终的AST转化为render函数字符串。</p>
</li>
</ul>
<h3 id="35-对SSR的理解"><a href="#35-对SSR的理解" class="headerlink" title="35. 对SSR的理解"></a>35. 对SSR的理解</h3><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p>
<p>SSR的优势：</p>
<ul>
<li><p>更好的SEO</p>
</li>
<li><p>首屏加载速度更快</p>
</li>
</ul>
<p>SSR的缺点：</p>
<ul>
<li><p>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</p>
</li>
<li><p>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</p>
</li>
<li><p>更多的服务端负载。</p>
</li>
</ul>
<h3 id="36-Vue的性能优化有哪些"><a href="#36-Vue的性能优化有哪些" class="headerlink" title="36. Vue的性能优化有哪些"></a>36. Vue的性能优化有哪些</h3><p>（1）编码阶段</p>
<ul>
<li><p>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</p>
</li>
<li><p>v-if和v-for不能连用</p>
</li>
<li><p>如果需要使用v-for给每项元素绑定事件时使用事件代理</p>
</li>
<li><p>SPA 页面采用keep-alive缓存组件</p>
</li>
<li><p>在更多的情况下，使用v-if替代v-show</p>
</li>
<li><p>key保证唯一</p>
</li>
<li><p>使用路由懒加载、异步组件</p>
</li>
<li><p>防抖、节流</p>
</li>
<li><p>第三方模块按需导入</p>
</li>
<li><p>长列表滚动到可视区域动态加载</p>
</li>
<li><p>图片懒加载</p>
</li>
</ul>
<p>（2）SEO优化</p>
<ul>
<li><p>预渲染</p>
</li>
<li><p>服务端渲染SSR</p>
</li>
</ul>
<p>（3）打包优化</p>
<ul>
<li><p>压缩代码</p>
</li>
<li><p>Tree Shaking&#x2F;Scope Hoisting</p>
</li>
<li><p>使用cdn加载第三方模块</p>
</li>
<li><p>多线程打包happypack</p>
</li>
<li><p>splitChunks抽离公共文件</p>
</li>
<li><p>sourceMap优化</p>
</li>
</ul>
<p>（4）用户体验</p>
<ul>
<li><p>骨架屏</p>
</li>
<li><p>PWA</p>
</li>
</ul>
<p>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</p>
<h3 id="37-对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#37-对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="37. 对 SPA 单页面的理解，它的优缺点分别是什么？"></a>37. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p>优点：</p>
<ul>
<li><p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</p>
</li>
<li><p>基于上面一点，SPA 相对对服务器压力小；</p>
</li>
<li><p>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</p>
</li>
<li><p>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</p>
</li>
<li><p>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</p>
</li>
</ul>
<h3 id="38-template和jsx的有什么分别？"><a href="#38-template和jsx的有什么分别？" class="headerlink" title="38. template和jsx的有什么分别？"></a>38. template和jsx的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。</p>
<p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>
<h3 id="39-vue初始化页面闪动问题"><a href="#39-vue初始化页面闪动问题" class="headerlink" title="39. vue初始化页面闪动问题"></a>39. vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p>
<p>首先：在css里加上以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有彻底解决问题，则在根元素加上style&#x3D;”display: none;” :style&#x3D;”{display: ‘block’}”</p>
<h3 id="40-extend-有什么作用"><a href="#40-extend-有什么作用" class="headerlink" title="40. extend 有什么作用"></a>40. extend 有什么作用</h3><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建组件构造器</span><br><span class="line">let Component = Vue.extend(&#123;</span><br><span class="line">  template: &#x27;&lt;div&gt;test&lt;/div&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">// 挂载到 #app 上</span><br><span class="line">new Component().$mount(&#x27;#app&#x27;)</span><br><span class="line">// 除了上面的方式，还可以用来扩展已有的组件</span><br><span class="line">let SuperComponent = Vue.extend(Component)</span><br><span class="line">new SuperComponent(&#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">new SuperComponent().$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="41-mixin-和-mixins-区别"><a href="#41-mixin-和-mixins-区别" class="headerlink" title="41. mixin 和 mixins 区别"></a>41. mixin 和 mixins 区别</h3><p>mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">        // ...逻辑</span><br><span class="line">        // 这种方式会影响到每个组件的 beforeCreate 钩子函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>虽然文档不建议在应用中直接使用 mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 ajax 或者一些工具函数等等。</p>
<p>mixins 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。</p>
<p>另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。</p>
<h3 id="42-MVVM的优缺点"><a href="#42-MVVM的优缺点" class="headerlink" title="42. MVVM的优缺点?"></a>42. MVVM的优缺点?</h3><p>优点: </p>
<ul>
<li><p>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑</p>
</li>
<li><p>提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</p>
</li>
<li><p>⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放</p>
</li>
</ul>
<p>缺点: </p>
<ul>
<li><p>Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的 </p>
</li>
<li><p>⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存</p>
</li>
<li><p>对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</p>
</li>
</ul>
<h3 id="43-v-if和v-for哪个优先级更高？如果同时出现，应如何优化？"><a href="#43-v-if和v-for哪个优先级更高？如果同时出现，应如何优化？" class="headerlink" title="43. v-if和v-for哪个优先级更高？如果同时出现，应如何优化？"></a>43. v-if和v-for哪个优先级更高？如果同时出现，应如何优化？</h3><p>v-for优先于v-if被解析，如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能。</p>
<p>要避免出现这种情况，则在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项。</p>
<h3 id="44-对Vue组件化的理解"><a href="#44-对Vue组件化的理解" class="headerlink" title="44. 对Vue组件化的理解"></a>44. 对Vue组件化的理解</h3><ol>
<li>组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；</li>
<li>组件化开发能大幅提高应用开发效率、测试性、复用性等；</li>
<li>组件使用按分类有：页面组件、业务组件、通用组件；</li>
<li>vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展于Vue；</li>
<li>vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；6.合理的划分组件，有助于提升应用性能；</li>
<li>组件应该是高内聚、低耦合的；</li>
<li>遵循单向数据流的原则。</li>
</ol>
<h3 id="45-对vue设计原则的理解"><a href="#45-对vue设计原则的理解" class="headerlink" title="45. 对vue设计原则的理解"></a>45. 对vue设计原则的理解</h3><ol>
<li>渐进式JavaScript框架：与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。</li>
<li>易用性：vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。</li>
<li>灵活性：渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。</li>
<li>高效性：超快的虚拟DOM和diﬀ算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。</li>
</ol>
<h3 id="46-常见的Vue性能优化方法"><a href="#46-常见的Vue性能优化方法" class="headerlink" title="46. 常见的Vue性能优化方法"></a>46. 常见的Vue性能优化方法</h3><ol>
<li>路由懒加载</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123; routes: [</span><br><span class="line">         &#123; path: &#x27;/foo&#x27;, component: () =&gt; import(&#x27;./Foo.vue&#x27;) &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>keep-alive缓存页面</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;router-view/&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用v-show复用DOM</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">     &lt;!--这种情况用v-show复用DOM，比v-if效果好--&gt;</span><br><span class="line">     &lt;div v-show=&quot;value&quot; class=&quot;on&quot;&gt;</span><br><span class="line">        &lt;Heavy :n=&quot;10000&quot;/&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">     &lt;section v-show=&quot;!value&quot; class=&quot;off&quot;&gt;</span><br><span class="line">        &lt;Heavy :n=&quot;10000&quot;/&gt;</span><br><span class="line">     &lt;/section&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>v-for 遍历避免同时使用 v-if</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">                 &lt;li v-for=&quot;user in activeUsers&quot; :key=&quot;user.id&quot;&gt;</span><br><span class="line">                          &#123;&#123; user.name &#125;&#125;</span><br><span class="line">                 &lt;/li&gt;</span><br><span class="line">         &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123; </span><br><span class="line">  computed: &#123;</span><br><span class="line">                 activeUsers: function () &#123;</span><br><span class="line">                          return this.users.filter(function (user) &#123; </span><br><span class="line">        return user.isActive</span><br><span class="line">      &#125;)</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>长列表性能优化</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化</span><br><span class="line">export default &#123; </span><br><span class="line">         data: () =&gt; (&#123;</span><br><span class="line">                 users: []</span><br><span class="line">         &#125;),</span><br><span class="line">         async created() &#123;</span><br><span class="line">                 const users = await axios.get(&quot;/api/users&quot;); </span><br><span class="line">                 this.users = Object.freeze(users);</span><br><span class="line">         &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容</span><br><span class="line">&lt;recycle-scroller class=&quot;items&quot; :items=&quot;items&quot; :item-size=&quot;24&quot;&gt;</span><br><span class="line">         &lt;template v-slot=&quot;&#123; item &#125;&quot;&gt;</span><br><span class="line">                 &lt;FetchItemView :item=&quot;item&quot; @vote=&quot;voteItem(item)&quot;/&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/recycle-scroller&gt;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>事件的销毁</li>
</ol>
<p>Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">         this.timer = setInterval(this.refresh, 2000)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123; </span><br><span class="line">         clearInterval(this.timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>图片懒加载</li>
</ol>
<p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>第三方插件按需引入</li>
</ol>
<p>像element-ui这样的第三方组件库可以按需引入避免体积太大。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">import &#123; Button, Select &#125; from &#x27;element-ui&#x27;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Vue.use(Button) Vue.use(Select)</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>无状态的组件标记为函数式组件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">         &lt;div class=&quot;cell&quot;&gt;</span><br><span class="line">                 &lt;div v-if=&quot;props.value&quot; class=&quot;on&quot;&gt;&lt;/div&gt;</span><br><span class="line">                 &lt;section v-else class=&quot;off&quot;&gt;&lt;/section&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">         export default &#123; props: [&#x27;value&#x27;] &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>子组件分隔</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">         &lt;div&gt;</span><br><span class="line">                 &lt;ChildComp/&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">         export default &#123; </span><br><span class="line">    components: &#123;</span><br><span class="line">                          ChildComp: &#123; </span><br><span class="line">        methods: &#123;</span><br><span class="line">                                           heavy () &#123; /* 耗时任务 */ &#125;</span><br><span class="line">                                   &#125;,</span><br><span class="line">                                   render (h) &#123;</span><br><span class="line">                                           return h(&#x27;div&#x27;, this.heavy())</span><br><span class="line">                                   &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>变量本地化</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">         &lt;div :style=&quot;&#123; opacity: start / 300 &#125;&quot;&gt;</span><br><span class="line">                 &#123;&#123; result &#125;&#125;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; heavy &#125; from &#x27;@/utils&#x27;</span><br><span class="line"> </span><br><span class="line">export default &#123; </span><br><span class="line">  props: [&#x27;start&#x27;], </span><br><span class="line">  computed: &#123;</span><br><span class="line">                 base () &#123; </span><br><span class="line">      return 42 </span><br><span class="line">    &#125;, </span><br><span class="line">    result () &#123;</span><br><span class="line">                          const base = this.base // 不要频繁引用this.base</span><br><span class="line">                          let result = this.start</span><br><span class="line">                          for (let i = 0; i &lt; 1000; i++) &#123; </span><br><span class="line">        result += heavy(base)</span><br><span class="line">                          &#125;</span><br><span class="line">                          return result</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>SSR</li>
</ol>
<h3 id="47-v-model的实现原理"><a href="#47-v-model的实现原理" class="headerlink" title="47. v-model的实现原理"></a>47. v-model的实现原理</h3><p>vue中v-model可以实现数据的双向绑定，但是为什么这个指令就可以实现数据的双向绑定呢？其实v-model是vue的一个语法糖。即利用v-model绑定数据后，既绑定了数据，又添加了一个input事件监听。</p>
<p>实现原理：</p>
<ul>
<li><p>v-bind绑定响应数据</p>
</li>
<li><p>触发input事件并传递数据</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;text&quot;&gt;&lt;/input&gt;</span><br><span class="line">// 等价于：</span><br><span class="line">&lt;input :value=&quot;text&quot; @input=&quot;text = $event.target.value&quot;&gt;&lt;/input&gt;</span><br><span class="line">// 组件中使用：</span><br><span class="line">&lt;custom-input :value=&quot;text&quot; @input=&quot;$event&quot;&gt;&lt;/custom-input&gt;</span><br><span class="line">// 根据v-model原理模拟：</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;ipt1&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;ipt2&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var ipt1=document.getElementById(&#x27;ipt1&#x27;);</span><br><span class="line">    var ipt2=document.getElementById(&#x27;ipt2&#x27;);</span><br><span class="line">    ipt1.addEventListener(&quot;input&quot;,function()&#123;</span><br><span class="line">        ipt2.value=ipt1.value;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>




    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">编程分享网站</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/vue/vue-life-cycle/" class="pre-post btn btn-default" title='VUE声明周期'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            VUE声明周期</span>
    </a>
    
    
    <a href="/redis/redis/" class="next-post btn btn-default" title='Redis面试'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            Redis面试</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Vue%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">1. Vue的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">2. 双向数据绑定的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-Object-defineProperty-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-MVVM%E3%80%81MVC%E3%80%81MVP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4. MVVM、MVC、MVP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Computed-%E5%92%8C-Watch-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5. Computed 和 Watch 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Computed-%E5%92%8C-Methods-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6. Computed 和 Methods 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-slot%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">7. slot是什么？有什么作用？原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">8. 过滤器的作用，如何实现一个过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%BD%93%E5%89%8D%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">9. 如何保存页面的当前的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-text">10. 常见的事件修饰符及其作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-v-if%E3%80%81v-show%E3%80%81v-html-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">11. v-if、v-show、v-html 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-v-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13.v-if和v-show的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-v-model-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E8%AF%AD%E6%B3%95%E7%B3%96%E5%AE%9E%E9%99%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">14.v-model 是如何实现的，语法糖实际是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-v-model-%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%94%A8%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E4%B8%8A%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AF%E4%BB%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-text">16. data为什么是一个函数而不是对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%85%B7%E4%BD%93%E7%BC%93%E5%AD%98%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-nextTick-%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-text">18. $nextTick 原理及作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Vue-%E4%B8%AD%E7%BB%99-data-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B1%9E%E6%80%A7%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Vue%E4%B8%AD%E5%B0%81%E8%A3%85%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%85%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E6%9B%B4%E6%96%B0"><span class="toc-text">20. Vue中封装的数组方法有哪些，其如何实现页面更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-Vue-%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%B8%8E%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">21. Vue 单页应用与多页应用的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-Vue-template-%E5%88%B0-render-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">22. Vue template 到 render 的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-Vue-data-%E4%B8%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98%E5%90%8E%EF%BC%8C%E8%A7%86%E5%9B%BE%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E5%90%97%EF%BC%9F"><span class="toc-text">23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E7%AE%80%E8%BF%B0-mixin%E3%80%81extends-%E7%9A%84%E8%A6%86%E7%9B%96%E9%80%BB%E8%BE%91"><span class="toc-text">24. 简述 mixin、extends 的覆盖逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E6%8F%8F%E8%BF%B0%E4%B8%8BVue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">25. 描述下Vue自定义指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E5%AD%90%E7%BB%84%E4%BB%B6%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%94%B9%E5%8F%98%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="toc-text">26. 子组件可以直接改变父组件的数据吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-Vue%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96%E7%9A%84%EF%BC%9F"><span class="toc-text">27. Vue是如何收集依赖的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%AF%B9-React-%E5%92%8C-Vue-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">28. 对 React 和 Vue 的理解，它们的异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-Vue%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">29. Vue的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-assets%E5%92%8Cstatic%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">30. assets和static的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-delete%E5%92%8CVue-delete%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">31. delete和Vue.delete删除数组的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E6%88%96%E8%80%85%E6%95%B0%E7%BB%84%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">32. vue如何监听对象或者数组某个属性的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E4%BB%80%E4%B9%88%E6%98%AF-mixin-%EF%BC%9F"><span class="toc-text">33. 什么是 mixin ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-Vue%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-text">34. Vue模版编译原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E5%AF%B9SSR%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">35. 对SSR的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-Vue%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">36. Vue的性能优化有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">37. 对 SPA 单页面的理解，它的优缺点分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-template%E5%92%8Cjsx%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%88%86%E5%88%AB%EF%BC%9F"><span class="toc-text">38. template和jsx的有什么分别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-vue%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E9%97%AA%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-text">39. vue初始化页面闪动问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-extend-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">40. extend 有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-mixin-%E5%92%8C-mixins-%E5%8C%BA%E5%88%AB"><span class="toc-text">41. mixin 和 mixins 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-MVVM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">42. MVVM的优缺点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-v-if%E5%92%8Cv-for%E5%93%AA%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E9%AB%98%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%EF%BC%8C%E5%BA%94%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">43. v-if和v-for哪个优先级更高？如果同时出现，应如何优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E5%AF%B9Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">44. 对Vue组件化的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E5%AF%B9vue%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">45. 对vue设计原则的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E5%B8%B8%E8%A7%81%E7%9A%84Vue%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">46. 常见的Vue性能优化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-v-model%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">47. v-model的实现原理</span></a></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2018 - 2023
                    
                </span> |
                <span>
                    <a href="//www.cicoding.com" class="copyright-links" target="_blank" rel="nofollow">编程分享网站</a>
                </span>|
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    <a href="//beian.miit.gov.cn" class="copyright-links" target="_blank" rel="nofollow">鲁ICP备18033870号</a>
                </span> |
                <span>
                    <a href="//beian.miit.gov.cn" class="copyright-links" target="_blank" rel="nofollow">鲁ICP备18033870号-1</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/assets/tagcanvas.min.js?rev=2.9.js"></script>

<script>
var tagOption = {
    textColour: '#444', // 字体颜色
    outlineMethod: 'block', // 选中模式
    outlineColour: '#FFDAB9', // 选中模式的颜色
    interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
    textHeight: 13,
    outlineRadius: 3,
    freezeActive: true || '', // 选中的标签是否继续滚动
    frontSelect: true || '', // 不选标签云后部的标签
    initial: [0.1, -0.1],
    depth: 0.5,
    decel: 0.95,
    maxSpeed: 0.03,
    reverse: true || '', // 是否反向触发
    fadeIn: 500, // 进入动画时间
    wheelZoom: false || '' // 是否启用鼠标滚轮
}
TagCanvas.Start('tag-cloud-3d', '', tagOption);
</script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash.js"></script>


</body>
</html>